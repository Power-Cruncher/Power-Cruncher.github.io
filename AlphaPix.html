<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AlphaPix</title>
<style>
  body {
    font-family: sans-serif;
    display: flex;
    gap: 20px;
    padding: 20px;
  }
  #sidebar {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 300px;
  }
  #main-area {
    display: flex;
    flex-direction: column;
    gap: 20px;
    flex: 1;
  }
  #canvas-section {
    display: flex;
    gap: 20px;
  }
  #board-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  #library-textbox {
    width: 200px;
    height: 30px;
    border: 1px solid #ccc;
    padding: 5px;
  }
  .library-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 5px;
    cursor: pointer;
    border: 1px solid transparent;
    margin-bottom: 5px;
  }
  .library-item:hover {
    background: #f0f0f0;
  }
  .library-item canvas {
    border: 1px solid #999;
  }
  #canvas-editor {
    border: 1px solid #ccc;
    padding: 15px;
    background: #f5f5f5;
  }
  #canvas-editor-grid {
    border: 2px solid #333;
    background: #fff;
    cursor: crosshair;
  }
  #tile-counts {
    border: 1px solid #ccc;
    padding: 10px;
    background: #f9f9f9;
  }
  .count-item {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 5px;
  }
  .count-color {
    width: 20px;
    height: 20px;
    border: 1px solid #333;
  }
  #library {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #ddd;
    padding: 10px;
    background: #fafafa;
  }
  #library-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 10px;
  }
  #font-selector {
    width: 100%;
    padding: 5px;
  }
  #filter-input {
    flex: 1;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 3px;
  }
  #filter-type {
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 3px;
    min-width: 80px;
  }
  .block {
    border: 1px solid #aaa;
    cursor: grab;
    image-rendering: pixelated;
  }
  .block.selected {
    border: 3px solid #ff0000;
  }
  .block.hidden {
    display: none;
  }
  .edit-cell {
    border: 1px solid #999;
    cursor: crosshair;
  }
  #blockEditor {
    border: 1px solid #ccc;
    padding: 15px;
    margin-top: 10px;
    background: #f5f5f5;
  }
  #board {
    position: relative;
    background: #f9f9f9;
    outline: 1px solid #333;
    display: grid;
    box-sizing: border-box;
    cursor: crosshair;
  }
  .grid-cell {
    width: 15px;
    height: 15px;
    border: 0.5px solid #eee;
    box-sizing: border-box;
  }
  .placed-block {
    position: absolute;
    image-rendering: pixelated;
    cursor: move;
    z-index: 10;
  }
  textarea {
    width: 100%;
    height: 200px;
  }
  label { font-weight: bold; }
  .loading {
    color: #666;
    font-style: italic;
  }
</style>
</head>
<body>

<div id="sidebar">
  <div id="library-controls">
    <label>Font Selection:</label>
    <select id="font-selector">
      <option value="">Loading fonts...</option>
    </select>
    
    <label>Filter Blocks:</label>
    <div style="display: flex; gap: 5px; align-items: center;">
      <select id="filter-type">
        <option value="id">ID</option>
        <option value="width">Width</option>
        <option value="height">Height</option>
      </select>
      <input type="text" id="filter-input" placeholder="Type to filter blocks...">
    </div>
  </div>

  <label>Library Blocks:</label>
  <div id="library"></div>

  <label>Block Editor:</label>
  <button id="newBlock">Create New Block</button>
  <button id="editBlock">Edit Selected Block</button>
  <button id="deleteBlock">Delete Selected Block</button>
  <div id="blockEditor" style="display: none;">
    <h3>Edit Block: <span id="editingBlockId"></span></h3>
    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
      <label>Block ID: <input type="text" id="blockId" placeholder="block_name"></label>
    </div>
    <div>
      <label>Height: <input type="number" id="editBlockHeight" value="5" min="1" max="20"></label>
      <label>Width: <input type="number" id="editBlockWidth" value="3" min="1" max="20"></label>
      <button id="resizeBlock">Resize Block</button>
    </div>
    <div style="display: flex; gap: 20px;">
      <div id="editCanvas" style="border: 1px solid #333; background: #fff; position: relative;"></div>
      <div>
        <label>Tile Type:</label><br>
        <input type="radio" name="cellType" value="pixel" id="pixelType" checked> Pixel<br>
        <input type="radio" name="cellType" value="tl" id="quarterType1"> Top-Left<br>
        <input type="radio" name="cellType" value="tr" id="quarterType2"> Top-Right<br>
        <input type="radio" name="cellType" value="bl" id="quarterType3"> Bottom-Left<br>
        <input type="radio" name="cellType" value="br" id="quarterType4"> Bottom-Right<br>
        <br>
        <label>Color: <input type="color" id="cellColor" value="#cccccc"></label><br><br>
        <button id="clearCanvas">Clear All</button><br>
      </div>
    </div>
    <div>
      <br>
      <button id="saveBlockEdit">Save Block</button><br>
      <button id="cancelEdit">Cancel</button>
    </div>
  </div>
  
  <label>Save / Load Library:</label>
  <button id="saveLibrary">Export to JSON</button>
  <button id="loadLibrary">Import from JSON</button>
  <textarea id="libraryJson"></textarea>
</div>

<div id="main-area">
  <div id="canvas-section">
    <div id="board-container">
      <div id="board"></div>
    </div>
  </div>
  
  <div>
    
    <label>Board Size :</label>
    <input type="number" id="boardHeight" value="2" min="8" max="128"> Ã—
    <input type="number" id="boardWidth" value="2" min="8" max="128">
    <button id="generateBoard">Resize</button>
    <div>
      <label>Add Letters:</label>
      <input type="text" id="library-textbox" placeholder="Type letters here...">
    </div>
  </div>

  <div>
    <label>Canvas Editor Tools:</label><br>
    <div style="display: flex; gap: 20px; margin-bottom: 10px;">
      <div>
        <label>Tile Type:</label><br>
        <input type="radio" name="canvasCellType" value="pixel" id="canvasPixelType" checked> Pixel<br>
        <input type="radio" name="canvasCellType" value="tl" id="canvasQuarter1"> Top-Left<br>
        <input type="radio" name="canvasCellType" value="tr" id="canvasQuarter2"> Top-Right<br>
        <input type="radio" name="canvasCellType" value="bl" id="canvasQuarter3"> Bottom-Left<br>
        <input type="radio" name="canvasCellType" value="br" id="canvasQuarter4"> Bottom-Right<br>
      </div>
      <div>
        <label>Color: <input type="color" id="canvasCellColor" value="#cccccc"></label><br>
        <button id="clearMainCanvas">Clear Main Canvas</button>
      </div>
    </div>
  </div>
  
  <div id="tile-counts">
    <h3>Tile Count</h3>
    <div id="count-display"></div>
  </div>
  
  <div>
    <label>Save / Load Board:</label><br>
    <button id="saveBoard">Save Board to JSON</button>
    <button id="loadBoard">Load Board from JSON</button>
    <br><textarea id="boardJson"></textarea>
  </div>
</div>

<script>
const cellSize = 15;
const cellSizeEdit = 40;
const blockSize = { width: 1, height: 1 };
let boardWidth = 32;
let boardHeight = 32;
let draggedData = null;
let libraryBlocks = [];
let availableFonts = [];
let currentFont = '';

const boardState = { width: boardWidth, height: boardHeight, blocks: [], canvas: [] };
const boardContainer = document.getElementById('board');
const boardJson = document.getElementById('boardJson');
const libraryJson = document.getElementById('libraryJson');
const boardInputWidth = document.getElementById('boardWidth');
const boardInputHeight = document.getElementById('boardHeight');
const fontSelector = document.getElementById('font-selector');
const filterInput = document.getElementById('filter-input');
const filterType = document.getElementById('filter-type');

let selectedLibraryBlock = null;
let editingBlock = null;
let editCanvas = null;

// --- Font Management ---
async function loadAvailableFonts() {
  try {
    // Try to fetch a directory listing or use a predefined list
    // Since we can't directly list directory contents, we'll try common font files
    const possibleFonts = ['04.json','06.json','07+ShadowDown.json','07.json','08.json','10+2xShadownLeft.json'];
    availableFonts = [];
    
    for (const font of possibleFonts) {
      try {
        const response = await fetch(`fonts/${font}`);
        if (response.ok) {
          availableFonts.push(font);
        }
      } catch (e) {
        // Font file doesn't exist, skip
      }
    }
    
    // Populate font selector
    fontSelector.innerHTML = '';
    if (availableFonts.length === 0) {
      fontSelector.innerHTML = '<option value="">No fonts found</option>';
    } else {
      fontSelector.innerHTML = '<option value="">Select a font...</option>';
      availableFonts.forEach(font => {
        const option = document.createElement('option');
        option.value = font;
        option.textContent = font.replace('.json', '');
        fontSelector.appendChild(option);
      });
      
      // Load first font by default if available
      if (availableFonts.length > 0) {
        fontSelector.value = availableFonts[0];
        currentFont = availableFonts[0];
        await loadFontFromFile(currentFont);
      }
    }
  } catch (error) {
    console.error('Error loading fonts:', error);
    fontSelector.innerHTML = '<option value="">Error loading fonts</option>';
  }
}

async function loadFontFromFile(fontFile) {
  if (!fontFile) return;
  
  try {
    const response = await fetch(`fonts/${fontFile}`);
    if (!response.ok) throw new Error('Font file not found');
    
    const fontData = await response.json();
    
    // Clear existing blocks and add new ones
    libraryBlocks = [];
    fontData.forEach(block => {
      const exists = libraryBlocks.some(b => b.id === block.id);
      if (!exists) {
        libraryBlocks.push(block);
      }
    });
    
    renderLibrary();
    currentFont = fontFile;
  } catch (error) {
    console.error('Error loading font:', error);
    alert(`Error loading font: ${fontFile}`);
  }
}

// Font selector event
fontSelector.addEventListener('change', async (e) => {
  if (e.target.value) {
    await loadFontFromFile(e.target.value);
  }
});

// --- Filter functionality ---
function filterLibraryBlocks() {
  const filterText = filterInput.value.toLowerCase().trim();
  const filterBy = filterType.value;
  const libraryDiv = document.getElementById('library');
  const blocks = libraryDiv.querySelectorAll('.block');
  
  blocks.forEach((block, index) => {
    const blockData = libraryBlocks[index];
    if (!blockData) return;
    
    let shouldShow = false;
    
    if (filterText === '') {
      shouldShow = true;
    } else {
      switch (filterBy) {
        case 'id':
          shouldShow = blockData.id.toLowerCase().includes(filterText);
          break;
        case 'width':
          shouldShow = blockData.width.toString().includes(filterText);
          break;
        case 'height':
          shouldShow = blockData.height.toString().includes(filterText);
          break;
        default:
          shouldShow = blockData.id.toLowerCase().includes(filterText);
      }
    }
    
    if (shouldShow) {
      block.classList.remove('hidden');
    } else {
      block.classList.add('hidden');
    }
  });
}

// Filter input and dropdown events
filterInput.addEventListener('input', filterLibraryBlocks);
filterType.addEventListener('change', () => {
  // Update placeholder text based on selected filter type
  const filterBy = filterType.value;
  switch (filterBy) {
    case 'id':
      filterInput.placeholder = 'Filter by ID...';
      break;
    case 'width':
      filterInput.placeholder = 'Filter by width (e.g., 3)...';
      break;
    case 'height':
      filterInput.placeholder = 'Filter by height (e.g., 5)...';
      break;
  }
  filterLibraryBlocks(); // Re-filter with new criteria
});

// --- Utility: Draw a cell ---
function drawCell(ctx, x, y, cellWidth, cellHeight, shape, color) {
  ctx.fillStyle = color;
  if (shape === 'pixel') {
    ctx.fillRect(x, y, cellWidth, cellHeight);
  } else {
    ctx.beginPath();
    const radius = Math.min(cellWidth, cellHeight) / 1;
    if (shape === 'tl') {
      ctx.moveTo(x + radius, y);
      ctx.arc(x + radius, y + radius, radius, 1.5 * Math.PI, Math.PI, true);
      ctx.lineTo(x, y + cellHeight);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x + cellWidth, y);
    } else if (shape === 'tr') {
      ctx.moveTo(x + cellWidth - radius, y);
      ctx.arc(x + cellWidth - radius, y + radius, radius, 1.5 * Math.PI, 0, false);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x, y + cellHeight);
      ctx.lineTo(x, y);
    } else if (shape === 'bl') {
      ctx.moveTo(x, y + cellHeight - radius);
      ctx.arc(x + radius, y + cellHeight - radius, radius, Math.PI, 0.5 * Math.PI, true);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x + cellWidth, y);
      ctx.lineTo(x, y);
    } else if (shape === 'br') {
      ctx.moveTo(x + cellWidth - radius, y + cellHeight);
      ctx.arc(x + cellWidth - radius, y + cellHeight - radius, radius, 0.5 * Math.PI, 0, true);
      ctx.lineTo(x + cellWidth, y);
      ctx.lineTo(x, y);
      ctx.lineTo(x, y + cellHeight);
    }
    ctx.closePath();
    ctx.fill();
  }
}

// --- Legacy import function (kept for compatibility) ---
function importFromJSON() {
  // This is now handled by the font loading system
}

// --- Render a block to canvas ---
function renderBlockToCanvas(blockData) {
  const canvas = document.createElement('canvas');
  canvas.className = 'block';
  const displayWidth = blockData.width * cellSize;
  const displayHeight = blockData.height * cellSize;
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  canvas.width = displayWidth;
  canvas.height = displayHeight;
  const ctx = canvas.getContext('2d');
  
  const cellWidth = displayWidth / blockData.width;
  const cellHeight = displayHeight / blockData.height;
  
  blockData.cells.forEach((row, y) => {
    row.forEach((cell, x) => {
      drawCell(ctx, x * cellWidth, y * cellHeight, cellWidth, cellHeight, cell.shape, cell.color);
    });
  });
  return canvas;
}

// --- Render Library ---
function renderLibrary() {
  const lib = document.getElementById('library');
  lib.innerHTML = '';
  libraryBlocks.forEach((block, index) => {
    const canvas = renderBlockToCanvas(block);
    canvas.draggable = true;
    canvas.dataset.blockIndex = index;
    canvas.title = `Block: ${block.id}`; // Add tooltip
    
    canvas.addEventListener('click', e => {
      e.preventDefault();
      selectLibraryBlock(index, canvas);
    });
    
    canvas.addEventListener('dragstart', e => {
      const rect = canvas.getBoundingClientRect();
      draggedData = {
        source: 'library',
        blockData: JSON.parse(JSON.stringify(block)),
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top
      };
    });
    lib.appendChild(canvas);
  });
  
  // Apply current filter
  filterLibraryBlocks();
}

// Trigger on any text input
const textbox = document.getElementById('library-textbox');
textbox.addEventListener('input', function () {
  const currentText  = textbox.value;
  // loop through each text input and try to match a block from the library
  if (currentText.length > 0) {
    const input = currentText[currentText.length - 1];
    libraryBlocks.forEach((block, index) => {
      if (input == block.id) {
        addBlockToMainCanvas(block);
        // console.log(block.id);
      }
    });
  }
});

function selectLibraryBlock(index, canvas) {
  document.querySelectorAll('.block').forEach(b => b.classList.remove('selected'));
  canvas.classList.add('selected');
  selectedLibraryBlock = index;
}

function addBlockToMainCanvas(blockData) {
  // Find a suitable position to place the block
  let placed = false;
  for (let y = 0; y <= boardHeight - blockData.height && !placed; y++) {
    for (let x = 0; x <= boardWidth - blockData.width && !placed; x++) {
      if (!isOverlapping(x, y, blockData)) {
        placeBlock(x, y, blockData);
        placed = true;
        updateTileCount();
      }
    }
  }
  if (!placed) {
    alert('No space available to place this block');
  }
}

// Initialize fonts on load
loadAvailableFonts();

// --- Generate Board ---
function generateBoard() {
  boardWidth = parseInt(boardInputWidth.value)*16;
  boardHeight = parseInt(boardInputHeight.value)*16;
  boardState.width = boardWidth;
  boardState.height = boardHeight;
  boardState.blocks = [];
  
  // Initialize canvas - only use boardState.canvas
  boardState.canvas = Array.from({length: boardHeight}, () => 
    Array.from({length: boardWidth}, () => ({ shape: 'pixel', color: '#ffffff' }))
  );

  boardContainer.innerHTML = '';
  boardContainer.style.width = `${boardWidth * cellSize}px`;
  boardContainer.style.height = `${boardHeight * cellSize}px`;
  boardContainer.style.gridTemplateColumns = `repeat(${boardWidth}, ${cellSize}px)`;
  boardContainer.style.gridTemplateRows = `repeat(${boardHeight}, ${cellSize}px)`;

  for (let i = 0; i < boardWidth * boardHeight; i++) {
    const cell = document.createElement('div');
    cell.className = 'grid-cell';
    
    // Add click handler for direct editing
    const row = Math.floor(i / boardWidth);
    const col = i % boardWidth;
    cell.addEventListener('click', () => editCanvasCell(col, row));
    
    boardContainer.appendChild(cell);
  }
  
  updateBoardVisuals();
  updateTileCount();
}

// --- Canvas Editor Functions ---
function updateBoardVisuals() {
  // Update the visual representation of the board based on boardState.canvas
  const cells = boardContainer.querySelectorAll('.grid-cell');
  
  boardState.canvas.forEach((row, y) => {
    row.forEach((cell, x) => {
      const index = y * boardWidth + x;
      const cellDiv = cells[index];
      if (cellDiv) {
        // Create or update canvas for this cell
        let canvas = cellDiv.querySelector('canvas');
        if (!canvas) {
          canvas = document.createElement('canvas');
          canvas.width = cellSize;
          canvas.height = cellSize;
          canvas.style.width = '100%';
          canvas.style.height = '100%';
          canvas.style.pointerEvents = 'none';
          cellDiv.appendChild(canvas);
        }
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, cellSize, cellSize);
        drawCell(ctx, 0, 0, cellSize, cellSize, cell.shape, cell.color);
      }
    });
  });
}

function editCell(x, y) {
  const cellType = document.querySelector('input[name="cellType"]:checked').value;
  const color = document.getElementById('cellColor').value;
  
  editingBlock.cells[y][x] = {
    shape: cellType,
    color: color
  };
  
  createEditCanvas();
}

document.getElementById('clearCanvas').addEventListener('click', () => {
  const newColor = document.getElementById('cellColor').value;
  editingBlock.cells = Array.from({length: editingBlock.height}, () => 
    Array.from({length: editingBlock.width}, () => ({ shape: 'pixel', color: newColor }))
  );
  createEditCanvas();
});

document.getElementById('saveBlockEdit').addEventListener('click', () => {
  const newId = document.getElementById('blockId').value.trim();
  if (!newId) {
    alert('Please enter a block ID');
    return;
  }
  
  editingBlock.id = newId;
  
  if (selectedLibraryBlock !== null) {
    libraryBlocks[selectedLibraryBlock] = editingBlock;
  } else {
    libraryBlocks.push(editingBlock);
  }
  
  renderLibrary();
  closeBlockEditor();
});

document.getElementById('cancelEdit').addEventListener('click', closeBlockEditor);

function closeBlockEditor() {
  document.getElementById('blockEditor').style.display = 'none';
  editingBlock = null;
  selectedLibraryBlock = null;
}

function editCanvasCell(x, y) {
  const cellType = document.querySelector('input[name="canvasCellType"]:checked').value;
  const color = document.getElementById('canvasCellColor').value;
  
  // Update only boardState.canvas - single source of truth
  boardState.canvas[y][x] = {
    shape: cellType,
    color: color
  };
  
  console.log(`Updated cell at (${x}, ${y}) with:`, boardState.canvas[y][x]);
  
  updateBoardVisuals();
  updateTileCount();
}

document.getElementById('clearMainCanvas').addEventListener('click', () => {
  const color = document.getElementById('canvasCellColor').value;
  
  // Reset only boardState.canvas
  boardState.canvas = Array.from({length: boardHeight}, () => 
    Array.from({length: boardWidth}, () => ({ shape: 'pixel', color: color }))
  );
  boardState.blocks = [];
  
  // Clear placed blocks from visual board
  document.querySelectorAll('.placed-block').forEach(block => block.remove());
  
  updateBoardVisuals();
  updateTileCount();
});

document.getElementById('generateBoard').addEventListener('click', generateBoard);
generateBoard();

// --- Drop logic ---
boardContainer.addEventListener('dragover', e => e.preventDefault());
boardContainer.addEventListener('drop', e => {
  e.preventDefault();
  if (!draggedData) return;
  const rect = boardContainer.getBoundingClientRect();
  const dropX = Math.floor((e.clientX - rect.left - draggedData.offsetX) / cellSize);
  const dropY = Math.floor((e.clientY - rect.top - draggedData.offsetY) / cellSize);
  const blockData = draggedData.blockData;
  if (
    dropX < 0 || dropX + blockData.width > boardWidth ||
    dropY < 0 || dropY + blockData.height > boardHeight
  ) {
    draggedData = null;
    return;
  }
  if (isOverlapping(dropX, dropY, blockData)) {
    alert('Block overlaps another.');
    draggedData = null;
    return;
  }
  placeBlock(dropX, dropY, draggedData.blockData);
  draggedData = null;
  updateTileCount();
});

function placeBlock(x, y, blockData) {
  const canvas = renderBlockToCanvas(blockData);
  canvas.className = 'placed-block';
  canvas.style.left = `${x * cellSize}px`;
  canvas.style.top = `${y * cellSize}px`;
  canvas.draggable = true;
  canvas.dataset.gridX = x;
  canvas.dataset.gridY = y;
  boardContainer.appendChild(canvas);

  boardState.blocks.push({ x, y, width: blockData.width, height: blockData.height, cells: blockData.cells });

  canvas.addEventListener('dragstart', e => {
    const rect = canvas.getBoundingClientRect();
    draggedData = {
      source: 'board',
      blockData: blockData,
      offsetX: e.clientX - rect.left,
      offsetY: e.clientY - rect.top
    };
    const idx = boardState.blocks.findIndex(b => b.x === x && b.y === y);
    if (idx >= 0) boardState.blocks.splice(idx, 1);
    boardContainer.removeChild(canvas);
    updateTileCount();
  });
}

function isOverlapping(gridX, gridY, blockData) {
  return boardState.blocks.some(block =>
    gridX < block.x + block.width &&
    gridX + blockData.width > block.x &&
    gridY < block.y + block.height &&
    gridY + blockData.height > block.y
  );
}

// --- Tile Count Function ---
function updateTileCount() {
  console.log('Updating tile count...'); // Debug log
  console.log('boardState:', boardState); // Debug log
  
  const counts = countUniqueShapeColor(boardState);
  const display = document.getElementById('count-display');
  display.innerHTML = '';
  
  console.log('Tile counts:', counts); // Debug log
  
  if (Object.keys(counts).length === 0) {
    display.innerHTML = '<div>No tiles to count</div>';
    return;
  }
  
  Object.entries(counts).forEach(([key, count]) => {
    const [shape, color] = key.split('|');
    const item = document.createElement('div');
    item.className = 'count-item';
    
    const colorDiv = document.createElement('div');
    colorDiv.className = 'count-color';
    colorDiv.style.backgroundColor = color;
    
    const text = document.createElement('span');
    text.textContent = `${shape}: ${count}`;
    
    item.appendChild(colorDiv);
    item.appendChild(text);
    display.appendChild(item);
  });
}

function countUniqueShapeColor(data) {
  const counts = {};
  
  console.log('Counting tiles in data:', data);

  // Count canvas cells (background/painted cells)
  if (data.canvas && Array.isArray(data.canvas)) {
    console.log('Processing canvas with', data.canvas.length, 'rows');
    for (let y = 0; y < data.canvas.length; y++) {
      const row = data.canvas[y];
      if (Array.isArray(row)) {
        for (let x = 0; x < row.length; x++) {
          const cell = row[x];
          if (cell && cell.color && cell.color !== '#ffffff') { // Skip white background cells
            let tile = ['tl','tr','bl','br'].includes(cell.shape) ? 'Quarter' : cell.shape;
            const key = `${tile}|${cell.color}`;
            counts[key] = (counts[key] || 0) + 1;
            console.log(`Canvas cell at (${x},${y}): ${tile}, ${cell.color}`);
          }
        }
      }
    }
  } else {
    console.log('No canvas data found or not an array');
  }

  // Count block cells
  if (data.blocks && Array.isArray(data.blocks)) {
    console.log('Processing', data.blocks.length, 'blocks');
    for (const block of data.blocks) {
      if (block.cells && Array.isArray(block.cells)) {
        for (const row of block.cells) {
          if (Array.isArray(row)) {
            for (const cell of row) {
              if (cell && cell.color && cell.shape) {
                let tile = ['tl','tr','bl','br'].includes(cell.shape) ? 'Quarter' : cell.shape;
                const key = `${tile}|${cell.color}`;
                counts[key] = (counts[key] || 0) + 1;
                console.log(`Block cell: ${tile}, ${cell.color}`);
              }
            }
          }
        }
      }
    }
  } else {
    console.log('No block data found or not an array');
  }

  console.log('Final counts:', counts);
  return counts;
}

// --- Save / Load Board ---
document.getElementById('saveBoard').addEventListener('click', () => {
  boardJson.value = JSON.stringify(boardState, null, 2);
});

document.getElementById('loadBoard').addEventListener('click', () => {
  try {
    const data = JSON.parse(boardJson.value);
    boardInputWidth.value = data.width / 16;
    boardInputHeight.value = data.height / 16;
    
    if (data.canvas) {
      boardState.canvas = data.canvas; // Direct assignment since we only have one source
    }
    
    generateBoard();
    
    if (data.blocks) {
      data.blocks.forEach(block => {
        placeBlock(block.x, block.y, { 
          width: block.width, 
          height: block.height, 
          cells: block.cells 
        });
      });
    }
    updateBoardVisuals();
    updateTileCount();
  } catch (e) {
    alert('Invalid JSON');
  }
});

// --- Save / Load Library ---
document.getElementById('saveLibrary').addEventListener('click', () => {
  libraryJson.value = JSON.stringify(libraryBlocks, null, 2);
});

document.getElementById('loadLibrary').addEventListener('click', () => {
  try {
    const data = JSON.parse(libraryJson.value);
    libraryBlocks = data;
    renderLibrary();
    selectedLibraryBlock = null;
  } catch (e) {
    alert('Invalid Library JSON');
  }
});

// --- Block Editor ---
document.getElementById('newBlock').addEventListener('click', () => {
  const newWidth = parseInt(document.getElementById('editBlockWidth').value) || 3;
  const newHeight = parseInt(document.getElementById('editBlockHeight').value) || 5;
  editingBlock = {
    id: `block_${Date.now()}`,
    width: newWidth,
    height: newHeight,
    cells: Array.from({length: newHeight}, () => 
      Array.from({length: newWidth}, () => ({ shape: 'pixel', color: '#cccccc' }))
    )
  };
  openBlockEditor();
});

document.getElementById('editBlock').addEventListener('click', () => {
  if (selectedLibraryBlock === null) {
    alert('Please select a block to edit first');
    return;
  }
  editingBlock = JSON.parse(JSON.stringify(libraryBlocks[selectedLibraryBlock]));
  openBlockEditor();
});

document.getElementById('deleteBlock').addEventListener('click', () => {
  if (selectedLibraryBlock === null) {
    alert('Please select a block to delete first');
    return;
  } else {
    libraryBlocks.splice(selectedLibraryBlock, 1);
    selectedLibraryBlock = null;
    renderLibrary();
  }
});

document.getElementById('resizeBlock').addEventListener('click', () => {
  if (!editingBlock) return;
  const newWidth = parseInt(document.getElementById('editBlockWidth').value);
  const newHeight = parseInt(document.getElementById('editBlockHeight').value);
  
  if (newWidth < 1 || newHeight < 1 || newWidth > 20 || newHeight > 20) {
    alert('Block size must be between 1x1 and 20x20');
    return;
  }
  
  const newCells = Array.from({length: newHeight}, (_, row) =>
    Array.from({length: newWidth}, (_, col) => {
      if (row < editingBlock.height && col < editingBlock.width && editingBlock.cells[row] && editingBlock.cells[row][col]) {
        return editingBlock.cells[row][col];
      }
      return { shape: 'pixel', color: '#cccccc' };
    })
  );
  
  editingBlock.width = newWidth;
  editingBlock.height = newHeight;
  editingBlock.cells = newCells;
  createEditCanvas();
});

function openBlockEditor() {
  document.getElementById('blockEditor').style.display = 'block';
  document.getElementById('editingBlockId').textContent = editingBlock.id;
  document.getElementById('blockId').value = editingBlock.id;
  document.getElementById('editBlockWidth').value = editingBlock.width;
  document.getElementById('editBlockHeight').value = editingBlock.height;
  createEditCanvas();
}

function createEditCanvas() {
  const container = document.getElementById('editCanvas');
  container.innerHTML = '';
  container.style.width = `${editingBlock.width * cellSizeEdit}px`;
  container.style.height = `${editingBlock.height * cellSizeEdit}px`;
  container.style.display = 'grid';
  container.style.gridTemplateColumns = `repeat(${editingBlock.width}, ${cellSizeEdit}px)`;
  container.style.gridTemplateRows = `repeat(${editingBlock.height}, ${cellSizeEdit}px)`;

  editingBlock.cells.forEach((row, y) => {
    row.forEach((cell, x) => {
      const cellDiv = document.createElement('div');
      cellDiv.className = 'edit-cell';
      cellDiv.style.width = `${cellSizeEdit}px`;
      cellDiv.style.height = `${cellSizeEdit}px`;
      cellDiv.dataset.x = x;
      cellDiv.dataset.y = y;
      
      const canvas = document.createElement('canvas');
      canvas.width = cellSizeEdit;
      canvas.height = cellSizeEdit;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.pointerEvents = 'none';
      
      const ctx = canvas.getContext('2d');
      drawCell(ctx, 0, 0, cellSizeEdit, cellSizeEdit, cell.shape, cell.color);
      
      cellDiv.appendChild(canvas);
      cellDiv.addEventListener('click', () => editCell(x, y));
      container.appendChild(cellDiv);
    });
  });
}

function editCell(x, y) {
  const cellType = document.querySelector('input[name="cellType"]:checked').value;
  const color = document.getElementById('cellColor').value;
  
  editingBlock.cells[y][x] = {
    shape: cellType,
    color: color
  };
  
  createEditCanvas(); // Refresh the edit canvas
}

document.getElementById('clearCanvas').addEventListener('click', () => {
  const newColor = document.getElementById('cellColor').value;
  editingBlock.cells = Array.from({length: editingBlock.height}, () => 
    Array.from({length: editingBlock.width}, () => ({ shape: 'pixel', color: newColor }))
  );
  createEditCanvas();
});

document.getElementById('saveBlockEdit').addEventListener('click', () => {
  const newId = document.getElementById('blockId').value.trim();
  if (!newId) {
    alert('Please enter a block ID');
    return;
  }
  
  editingBlock.id = newId;
  console.log(editingBlock.id);
  console.log(newId);
  if (selectedLibraryBlock !== null) {
    // Editing existing block
    libraryBlocks[selectedLibraryBlock] = editingBlock;
  } else {
    // Adding new block
    libraryBlocks.push(editingBlock);
  }
  
  renderLibrary();
  closeBlockEditor();
});

document.getElementById('cancelEdit').addEventListener('click', closeBlockEditor);

function closeBlockEditor() {
  document.getElementById('blockEditor').style.display = 'none';
  editingBlock = null;
  selectedLibraryBlock = null;
}

</script>

</body>
</html>