<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AlphaPix</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    display: flex;
    gap: 20px;
    padding: 20px;
    margin: 0;
    background: #fff;
  }

  #main-area {
    display: flex;
    flex-direction: column;
    gap: 20px;
    flex: 1;
  }

  #sidebar {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 320px;
    background: #fafafa;
    padding: 15px;
    border-radius: 8px;
    border: 1px solid #ddd;
  }

  .section {
    background: #fafafa;
    padding: 15px;
    border-radius: 8px;
    border: 1px solid #ddd;
  }

  .section h3 {
    margin: 0 0 10px 0;
    color: #333;
  }

  .color-palette {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 4px;
    margin: 10px 0;
  }

  .color-swatch {
    width: 30px;
    height: 30px;
    border: 2px solid #999;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .color-swatch:hover, .color-swatch.selected {
    transform: scale(1.1);
    border-color: #ff0000;
  }

  input, select, textarea, button {
    padding: 8px;
    border: 1px solid #999;
    border-radius: 4px;
    font-family: inherit;
  }

  button {
    background: white;
    cursor: pointer;
  }

  button:hover {
    background: #f5f5f5;
  }

  #library {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 10px;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #ddd;
    padding: 10px;
    background: white;
    border-radius: 4px;
  }

  .block {
    border: 1px solid #999;
    cursor: grab;
    image-rendering: pixelated;
    border-radius: 2px;
    justify-self: center;
  }

  .block.selected {
    border: 3px solid #ff0000;
  }

  .block.hidden {
    display: none;
  }

  #board {
    position: relative;
    background: #0055bf;
    outline: 2px solid #333;
    box-sizing: border-box;
    cursor: crosshair;
    border-radius: 4px;
  }

  .placed-block {
    position: absolute;
    image-rendering: pixelated;
    cursor: move;
    z-index: 10;
    border-radius: 2px;
  }

  .placed-block.dragging {
    opacity: 0.7;
    z-index: 20;
  }

  .placed-block.selected {
    box-shadow: 0 0 0 3px #ff6b6b;
    z-index: 15;
  }

  /* Block Editor Modal Styles */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    display: none;
    align-items: center;
    justify-content: center;
  }

  .modal-content {
    background: white;
    border-radius: 12px;
    padding: 20px;
    max-width: 80vw;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    position: relative;
  }

  .modal-close {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #999;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .modal-close:hover {
    color: #333;
    background: #f0f0f0;
    border-radius: 50%;
  }

  #block-editor {
    background: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 15px;
  }

  #edit-canvas {
    border: 2px solid #333;
    background: white;
    border-radius: 4px;
  }

  .edit-cell {
    border: 1px solid #999;
    cursor: crosshair;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 15px;
  }

  .control-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .tile-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin: 15px 0;
  }

  .tile-type-selector {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    margin: 10px 0;
  }

  .tile-type-option {
    width: 40px;
    height: 40px;
    border: 2px solid #999;
    border-radius: 6px;
    cursor: pointer;
    background: white;
    transition: all 0.2s ease;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .tile-type-option:hover, .tile-type-option.selected {
    transform: scale(1.05);
    border-color: #ff0000;
    background: #f0f8ff;
  }

  .tile-type-option canvas {
    width: 30px;
    height: 30px;
    border-radius: 2px;
  }

  .tile-type-option.bucket-fill {
    font-size: 20px;
    color: #333;
    font-weight: bold;
  }

  .tile-type-label {
    font-size: 11px;
    color: #333;
    text-align: center;
    margin-top: 4px;
    font-weight: 500;
  }

  .count-item {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    padding: 6px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
  }

  .section-group {
    display: flex;
    gap: 20px;
    align-items: flex-start;
  }

  .section-group .section {
    flex: 1;               /* allow both to grow equally */
    min-width: 0;          /* prevents overflow */
  }

  @media (max-width: 1200px) {
    body {
      flex-direction: column;
    }
    
    #sidebar {
      width: 100%;
    }
  }
</style>
</head>
<body>

<div id="main-area">
  <div class="section">
    <div id="board-container">
      <canvas id="board"></canvas>
    </div>
  </div>
  
  <div class="section">
    <h3>Board Controls</h3>
    <div class="control-row">
      <label>Board Size:</label>
      <input type="number" id="board-height" value="1" min="1" max="8"> Ã—
      <input type="number" id="board-width" value="4" min="1" max="8">
      <button id="generate-board">Resize</button>
      <button id="clear-main-canvas">Clear Board</button>
      <button id="center-text">Center Text</button>
      <button id="print-board">Print Board</button>
    </div>
  </div>

  <div class="section-group">
    <div class="section">
      <h3>Canvas Editor Tools</h3>
      <div class="tile-controls">
        <div>
          <label><strong>Tool:</strong></label>
          <div class="tile-type-selector" id="canvas-tile-selector"></div>
        </div>
        <br>
        <div>
          <label><strong>Color:</strong></label>
          <input type="color" id="canvas-cell-color" value="#ff0000">
          <div class="color-palette" id="canvas-palette"></div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <h3>Tile Count</h3>
      <div id="count-display"></div>
    </div>
  </div>
  
  <div class="section">
    <h3>Save / Load Board</h3>
    <div class="control-row">
      <button id="save-board">Save Board</button>
      <button id="load-board">Load Board</button>
    </div>
    <textarea id="board-json" rows="4"></textarea>
  </div>
</div>

<div id="sidebar">
  <div class="section">
    <h3>Font Selection</h3>
    <select id="font-selector">
      <option value="">Loading fonts...</option>
    </select>
  </div>

  <div class="section">
    <h3>Filter Blocks</h3>
    <div class="control-row">
      <select id="filter-type">
        <option value="id">ID</option>
        <option value="width">Width</option>
        <option value="height">Height</option>
      </select>
      <input type="text" id="filter-input" placeholder="Type to filter blocks...">
    </div>
  </div>

  <div class="section">
    <h3>Library Blocks</h3>
    <div id="library"></div>
  </div>

  <div class="section">
    <h3>Block Editor</h3>
    <div class="control-row">
      <button id="new-block">Create New</button>
      <button id="edit-block">Edit Selected</button>
      <button id="delete-block">Delete</button>
    </div>
  </div>
  
  <div class="section">
    <h3>Save / Load Library</h3>
    <div class="control-row">
      <button id="save-library">Export JSON</button>
      <button id="load-library">Import JSON</button>
    </div>
    <textarea id="library-json" rows="4"></textarea>
  </div>
</div>

<!-- Block Editor Modal -->
<div class="modal-overlay" id="editor-modal">
  <div class="modal-content">
    <button class="modal-close" onclick="closeBlockEditor()">Ã—</button>
    <div id="block-editor">
      <h3>Edit Block: <span id="editing-block-id"></span></h3>
      <div class="control-group">
        <label>Block ID: <input type="text" id="block-id" placeholder="block_name"></label>
      </div>
      <div class="control-row">
        <label>Width: <input type="number" id="edit-block-width" value="3" min="1" max="20"></label>
        <label>Height: <input type="number" id="edit-block-height" value="5" min="1" max="20"></label>
        <button id="resize-block">Resize</button>
      </div>
      
      <div class="tile-controls">
        <div>
          <label><strong>Tile Type:</strong></label>
          <div class="tile-type-selector" id="editor-tile-selector"></div>
        </div>
        <br>
        <div id="edit-canvas"></div><br>
        <div>
          <label><strong>Color:</strong></label>
          <input type="color" id="cell-color" value="#cccccc">
          <div class="color-palette" id="editor-palette"></div>
        </div>
      </div>
      <div class="control-row" style="margin-top: 15px;">
        <button id="clear-canvas">Clear All</button>
        <button id="save-block-edit">Save Block</button>
        <button id="cancel-edit">Cancel</button>
      </div>
    </div>
  </div>
</div>

<script>
// === GLOBAL VARIABLES ===
const CONFIG = {
  cellSize: 15,
  editCellSize: 40,
  maxBoardSize: 128,
  minBoardSize: 8,
  maxBlockSize: 20,
  minBlockSize: 1
};

const possibleFonts = ['03.json', '04.json','06.json','07+ShadowDown.json',
  '07.json','08.json','09+2xShadownLeft.json','10+2xShadownLeft.json', 'Shapes.json'];
const borderColor = '#078bc9fe';
const COLOR_PALETTE = [
  '#ff0000', '#CCCCCC', "#808080", "#000000", "#FFFFFF",
  "#078bc9", "#ff698f", "#e1d5ed", "#4b9f4a", "#f2cd37"
];
const COLOR_NAMES = [
  "Red", "Grey", "Dark Grey", "Black", "White",
  "Dark Azure", "Coral", "Lavender", "Bright Green", "Yellow"
];
const blockBackground = '#ffffff00';

let boardWidth = 32;
let boardHeight = 32;
let draggedData = null;
let libraryBlocks = [];
let availableFonts = [];
let currentFont = '';
let selectedLibraryBlock = null;
let editingBlock = null;
let boardState = {
  width: 32,
  height: 32,
  blocks: []
};

let editorSelectedType = 'pixel';
let canvasSelectedType = 'pixel';
let editorSelectedElement = null;
let canvasSelectedElement = null;

// Block drag state
let isDragging = false;
let draggedBlock = null;
let dragOffset = { x: 0, y: 0 };

// === UTILITY FUNCTIONS ===
function drawCell(ctx, x, y, cellWidth, cellHeight, shape, color) {
  ctx.fillStyle = color;
  if (shape === 'pixel') {
    ctx.fillRect(x, y, cellWidth, cellHeight);
    return;
  }

  ctx.beginPath();
  const radius = Math.min(cellWidth, cellHeight) / 1;
  
  switch (shape) {
    case 'tl':
      ctx.moveTo(x + radius, y);
      ctx.arc(x + radius, y + radius, radius, 1.5 * Math.PI, Math.PI, true);
      ctx.lineTo(x, y + cellHeight);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x + cellWidth, y);
      break;
    case 'tr':
      ctx.moveTo(x + cellWidth - radius, y);
      ctx.arc(x + cellWidth - radius, y + radius, radius, 1.5 * Math.PI, 0, false);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x, y + cellHeight);
      ctx.lineTo(x, y);
      break;
    case 'bl':
      ctx.moveTo(x, y + cellHeight - radius);
      ctx.arc(x + radius, y + cellHeight - radius, radius, Math.PI, 0.5 * Math.PI, true);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x + cellWidth, y);
      ctx.lineTo(x, y);
      break;
    case 'br':
      ctx.moveTo(x + cellWidth - radius, y + cellHeight);
      ctx.arc(x + cellWidth - radius, y + cellHeight - radius, radius, 0.5 * Math.PI, 0, true);
      ctx.lineTo(x + cellWidth, y);
      ctx.lineTo(x, y);
      ctx.lineTo(x, y + cellHeight);
      break;
  }
  ctx.closePath();
  ctx.fill();
}

function createElement(tag, className = '', attributes = {}) {
  const element = document.createElement(tag);
  if (className) element.className = className;
  Object.entries(attributes).forEach(([key, value]) => {
    element.setAttribute(key, value);
  });
  return element;
}

function hasAlpha(colorString) {
  // Check if it's a hex color with alpha
  if (colorString.length === 9 && colorString.startsWith('#')) {
    const alpha = parseInt(colorString.slice(7), 16);
    return alpha < 255;
  }
  // Check if it's rgba format
  if (colorString.startsWith('rgba')) {
    const values = colorString.match(/[\d.]+/g);
    return values && parseFloat(values[3]) < 1;
  }
  return false;
}

function countTiles(boardState) {
  const counts = {};

  if (boardState.blocks && Array.isArray(boardState.blocks)) {
    boardState.blocks.forEach(block => {
      if (block.cells && Array.isArray(block.cells)) {
        block.cells.forEach(row => {
          if (Array.isArray(row)) {
            row.forEach(cell => {
              if (cell && cell.color && cell.shape && !hasAlpha(cell.color)) {
                const tile = ['tl','tr','bl','br'].includes(cell.shape) ? 'tl' : cell.shape;
                const key = `${tile}|${cell.color}`;
                counts[key] = (counts[key] || 0) + 1;
              }
            });
          }
        });
      }
    });
  }

  const sorted = Object.entries(counts)
    .map(([key, count]) => {
      const [shape, color] = key.split('|');
      return { shape, color, count };
    })
    .sort((a, b) => b.count - a.count);

  return sorted;
}

// === TILE TYPE SELECTOR FUNCTIONS ===
function initTileTypeSelector(containerId, selectedTypeVar, selectedElementVar, options = { bucket: true, eraser: true }) {
  const container = document.getElementById(containerId);
  const tileTypes = [
    { value: 'pixel', label: '3070b' },
    { value: 'tl', label: '25269' },
    { value: 'tr', label: '25269' },
    { value: 'bl', label: '25269' },
    { value: 'br', label: '25269' }
  ];

  if (options.bucket) {
    tileTypes.push({ value: 'bucket', label: 'Fill' });
  }
  if (options.eraser) {
    tileTypes.push({ value: 'eraser', label: 'Erase' });
  }

  container.innerHTML = '';
  
  tileTypes.forEach(tileType => {
    const wrapper = createElement('div');
    wrapper.style.textAlign = 'center';
    
    const option = createElement('div', 'tile-type-option');
    option.dataset.tileType = tileType.value;
    
    if (tileType.value === 'bucket') {
      option.classList.add('bucket-fill');
      option.textContent = 'ðŸª£';
    }
    else if (tileType.value === 'eraser') {
      option.classList.add('bucket-fill');
      option.textContent = 'ðŸ§½';
    }
    else {
      const canvas = createElement('canvas');
      canvas.width = 30;
      canvas.height = 30;
      const ctx = canvas.getContext('2d');
      
      drawCell(ctx, 5, 5, 20, 20, tileType.value, '#666666');
      option.appendChild(canvas);
    }
    
    const label = createElement('div', 'tile-type-label');
    label.textContent = tileType.label;
    
    wrapper.appendChild(option);
    wrapper.appendChild(label);
    
    option.addEventListener('click', () => {
      if (selectedElementVar === 'editor') {
        if (editorSelectedElement) {
          editorSelectedElement.classList.remove('selected');
        }
        option.classList.add('selected');
        editorSelectedElement = option;
        editorSelectedType = tileType.value;
      } else {
        if (canvasSelectedElement) {
          canvasSelectedElement.classList.remove('selected');
        }
        option.classList.add('selected');
        canvasSelectedElement = option;
        canvasSelectedType = tileType.value;
      }
    });
    
    if (tileType.value === 'pixel') {
      option.classList.add('selected');
      if (selectedElementVar === 'editor') {
        editorSelectedElement = option;
      } else {
        canvasSelectedElement = option;
      }
    }
    
    container.appendChild(wrapper);
  });
}

function getSelectedTileType(selector) {
  return selector === 'editor' ? editorSelectedType : canvasSelectedType;
}

// === COLOR PALETTE FUNCTIONS ===
function initColorPalette(containerId, colorInputId) {
  const container = document.getElementById(containerId);
  const colorInput = document.getElementById(colorInputId);
  let selectedSwatch = null;

  container.innerHTML = '';
  COLOR_PALETTE.forEach(color => {
    const swatch = createElement('div', 'color-swatch');
    swatch.style.backgroundColor = color;
    swatch.dataset.color = color;
    swatch.addEventListener('click', () => {
      if (selectedSwatch) {
        selectedSwatch.classList.remove('selected');
      }
      swatch.classList.add('selected');
      selectedSwatch = swatch;
      colorInput.value = color;
    });
    container.appendChild(swatch);
  });

  colorInput.addEventListener('change', (e) => {
    if (selectedSwatch) {
      selectedSwatch.classList.remove('selected');
      selectedSwatch = null;
    }
  });
}

// === FONT MANAGEMENT FUNCTIONS ===
async function loadAvailableFonts() {
  try {
    availableFonts = [];
    
    for (const font of possibleFonts) {
      try {
        const response = await fetch(`fonts/${font}`);
        if (response.ok) {
          availableFonts.push(font);
        }
      } catch (e) {
        // Font doesn't exist, skip
      }
    }
    
    populateFontSelector();
  } catch (error) {
    console.error('Error loading fonts:', error);
    document.getElementById('font-selector').innerHTML = '<option value="">Error loading fonts</option>';
  }
}

function populateFontSelector() {
  const fontSelector = document.getElementById('font-selector');
  fontSelector.innerHTML = '';
  if (availableFonts.length === 0) {
    fontSelector.innerHTML = '<option value="">No fonts found</option>';
  } else {
    fontSelector.innerHTML = '<option value="">Select a font...</option>';
    availableFonts.forEach(font => {
      const option = createElement('option', '', { value: font });
      option.textContent = font.replace('.json', '');
      fontSelector.appendChild(option);
    });
    
    if (availableFonts.length > 1) {
      fontSelector.value = availableFonts[1];
      loadFont(availableFonts[1]);
    }
  }
}

async function loadFont(fontFile) {
  if (!fontFile) return;
  
  try {
    const response = await fetch(`fonts/${fontFile}`);
    if (!response.ok) throw new Error('Font file not found');
    
    const fontData = await response.json();
    libraryBlocks = [];
    
    fontData.forEach(block => {
      const exists = libraryBlocks.some(b => b.id === block.id);
      if (!exists) {
        libraryBlocks.push(block);
      }
    });
    
    renderLibrary();
    currentFont = fontFile;
  } catch (error) {
    console.error('Error loading font:', error);
    alert(`Error loading font: ${fontFile}`);
  }
}

// === LIBRARY RENDERING FUNCTIONS ===
function renderLibrary() {
  const libraryContainer = document.getElementById('library');
  libraryContainer.innerHTML = '';
  libraryBlocks.forEach((block, index) => {
    const canvas = renderBlockToCanvas(block);
    canvas.draggable = true;
    canvas.dataset.blockIndex = index;
    canvas.title = `Block: ${block.id}`;
    
    canvas.addEventListener('click', (e) => {
      e.preventDefault();
      selectBlock(index, canvas);
    });
    
    canvas.addEventListener('dragstart', (e) => {
      const rect = canvas.getBoundingClientRect();
      draggedData = {
        source: 'library',
        blockData: JSON.parse(JSON.stringify(block)),
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top
      };
    });
    
    libraryContainer.appendChild(canvas);
  });
  
  applyFilter();
}

function renderBlockToCanvas(blockData) {
  const canvas = createElement('canvas', 'block');
  const displayWidth = blockData.width * CONFIG.cellSize;
  const displayHeight = blockData.height * CONFIG.cellSize;
  
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  canvas.width = displayWidth;
  canvas.height = displayHeight;
  
  const ctx = canvas.getContext('2d');
  const cellWidth = displayWidth / blockData.width;
  const cellHeight = displayHeight / blockData.height;
  
  blockData.cells.forEach((row, y) => {
    row.forEach((cell, x) => {
      drawCell(ctx, x * cellWidth, y * cellHeight, cellWidth, cellHeight, cell.shape, cell.color);
    });
  });
  
  return canvas;
}

function selectBlock(index, canvas) {
  document.querySelectorAll('.block').forEach(b => b.classList.remove('selected'));
  canvas.classList.add('selected');
  selectedLibraryBlock = index;
}

function applyFilter() {
  const filterInput = document.getElementById('filter-input');
  const filterType = document.getElementById('filter-type');
  const filterText = filterInput.value.toLowerCase().trim();
  const filterBy = filterType.value;
  const blocks = document.getElementById('library').querySelectorAll('.block');
  
  blocks.forEach((block, index) => {
    const blockData = libraryBlocks[index];
    if (!blockData) return;
    
    let shouldShow = filterText === '';
    
    if (!shouldShow) {
      switch (filterBy) {
        case 'id':
          shouldShow = blockData.id.toLowerCase().includes(filterText);
          break;
        case 'width':
          shouldShow = blockData.width.toString().includes(filterText);
          break;
        case 'height':
          shouldShow = blockData.height.toString().includes(filterText);
          break;
      }
    }
    
    block.classList.toggle('hidden', !shouldShow);
  });
}

// === BOARD MANAGEMENT FUNCTIONS ===
function setBoardSize(width, height) {
  boardWidth = width;
  boardHeight = height;
  boardState.width = width;
  boardState.height = height;
}

function clearBoard() {
  boardState.blocks = [];
  updateTileCount();
}

function generateBoard() {
  const widthInput = document.getElementById('board-width');
  const heightInput = document.getElementById('board-height');
  
  const newWidth = Math.max(CONFIG.minBoardSize, Math.min(CONFIG.maxBoardSize, parseInt(widthInput.value) * 16));
  const newHeight = Math.max(CONFIG.minBoardSize, Math.min(CONFIG.maxBoardSize, parseInt(heightInput.value) * 16));
  
  setBoardSize(newWidth, newHeight);
  boardState.blocks = [];
  
  renderBoard();
  updateTileCount();
  addBorder();
}

function editCanvasCell(x, y) {
  const cellType = getSelectedTileType('canvas');
  const color = document.getElementById('canvas-cell-color').value;
  
  if (cellType === 'bucket') {
    bucketFill(x, y, color);
    return;
  }
  
  const canvasBlockId = `canvas_${x}_${y}_${Date.now()}`;
  const canvasBlock = {
    id: canvasBlockId,
    width: 1,
    height: 1,
    cells: [[{ shape: cellType, color: color }]]
  };
  
  placeBlock(x, y, canvasBlock);
  updateTileCount();
}

function bucketFill(clickX, clickY, newColor) {
  const targetBlock = findBlockAt(clickX, clickY);
  if (!targetBlock) return;

  const cellX = clickX - targetBlock.x;
  const cellY = clickY - targetBlock.y;
  const clickedCell = targetBlock.cells[cellY]?.[cellX];
  if (!clickedCell || hasAlpha(clickedCell.color)) return;

  const originalColor = clickedCell.color;
  if (originalColor === newColor) return;

  for (let y = 0; y < targetBlock.height; y++) {
    for (let x = 0; x < targetBlock.width; x++) {
      const cell = targetBlock.cells[y][x];
      if (cell && cell.color === originalColor && !hasAlpha(cell.color)) {
        cell.color = newColor;
      }
    }
  }
}

function addBorder() {
  const borderH = {
    id: 'borderH',
    width: (boardWidth-2),
    height: 1,
    cells: [
      Array.from({ length: boardWidth-2 }, () => ({ shape: 'pixel', color: borderColor }))
    ]
  };
  const borderV = {
    id: 'borderV',
    width: 1,
    height: boardHeight,
    cells: Array.from({ length: boardHeight }, () => [{ shape: 'pixel', color: borderColor }])
  };
  
  placeBlock(1, 0, borderH);
  placeBlock(1, (boardHeight-1), borderH);
  placeBlock(0, 0, borderV);
  placeBlock((boardWidth-1), 0, borderV);
  updateTileCount();
}

// === PRINT FUNCTION ===
function printBoard() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas size to match board
  canvas.width = boardWidth * CONFIG.cellSize;
  canvas.height = boardHeight * CONFIG.cellSize;
  
  // Fill with white background
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw grid lines like the editor (#eee)
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 0.5;

  // Vertical lines
  for (let x = 0; x <= boardWidth; x++) {
    ctx.beginPath();
    ctx.moveTo(x * CONFIG.cellSize + 0.5, 0);
    ctx.lineTo(x * CONFIG.cellSize + 0.5, canvas.height);
    ctx.stroke();
  }
  // Horizontal lines
  for (let y = 0; y <= boardHeight; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * CONFIG.cellSize + 0.5);
    ctx.lineTo(canvas.width, y * CONFIG.cellSize + 0.5);
    ctx.stroke();
  }

  // Draw all blocks
  boardState.blocks.forEach(block => {
    const blockCanvas = renderBlockToCanvas(block);
    ctx.drawImage(blockCanvas, block.x * CONFIG.cellSize, block.y * CONFIG.cellSize);
  });
  
  // Convert to blob and open in new tab
  canvas.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const newTab = window.open();
    newTab.document.write(`
      <html>
        <head><title>AlphaPix Board</title></head>
        <body style="margin:0;padding:20px;background:#f0f0f0;display:flex;justify-content:center;align-items:center;min-height:100vh;">
          <img src="${url}" style="max-width:100%;max-height:100%;image-rendering:pixelated;border:2px solid #333;">
        </body>
      </html>
    `);
  }, 'image/png');
}

function placeBlock(x, y, blockData) {
  // Deep clone
  const cloned = JSON.parse(JSON.stringify(blockData));

  // Assign ID
  const blockId = `block_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
  cloned.id = blockId;
  cloned.x = x;
  cloned.y = y;

  boardState.blocks.push(cloned);
  renderBoard();
  updateTileCount();
}

function isOverlapping(gridX, gridY, blockData) {
  return boardState.blocks.some(block =>
    gridX < block.x + block.width &&
    gridX + blockData.width > block.x &&
    gridY < block.y + block.height &&
    gridY + blockData.height > block.y
  );
}

function addBlockToBoard(blockData) {
  let placed = false;
  for (let y = 0; y <= boardHeight - blockData.height && !placed; y++) {
    for (let x = 0; x <= boardWidth - blockData.width && !placed; x++) {
      if (!isOverlapping(x, y, blockData)) {
        placeBlock(x, y, blockData);
        placed = true;
        updateTileCount();
      }
    }
  }
  if (!placed) {
    alert('No space available to place this block');
  }
}

function findBlockAt(x, y) {
  return boardState.blocks.find(block =>
    x >= block.x && x < block.x + block.width &&
    y >= block.y && y < block.y + block.height
  );
}

// === BLOCK EDITOR FUNCTIONS ===
function openNewBlockEditor() {
  const width = Math.max(1, Math.min(20, parseInt(document.getElementById('edit-block-width').value) || 3));
  const height = Math.max(1, Math.min(20, parseInt(document.getElementById('edit-block-height').value) || 5));
  
  editingBlock = {
    id: `block_${Date.now()}`,
    width: width,
    height: height,
    cells: Array.from({length: height}, () => 
      Array.from({length: width}, () => ({ shape: 'pixel', color: blockBackground }))
    )
  };
  openBlockEditor();
}

function openExistingBlockEditor() {
  if (selectedLibraryBlock === null) {
    alert('Please select a block to edit first');
    return;
  }
  editingBlock = JSON.parse(JSON.stringify(libraryBlocks[selectedLibraryBlock]));
  openBlockEditor();
}

function openBlockEditor() {
  const modal = document.getElementById('editor-modal');
  modal.style.display = 'flex';
  document.getElementById('editing-block-id').textContent = editingBlock.id;
  document.getElementById('block-id').value = editingBlock.id;
  document.getElementById('edit-block-width').value = editingBlock.width;
  document.getElementById('edit-block-height').value = editingBlock.height;
  renderEditCanvas();
}

function closeBlockEditor() {
  const modal = document.getElementById('editor-modal');
  modal.style.display = 'none';
  editingBlock = null;
  selectedLibraryBlock = null;
}

function renderEditCanvas() {
  const editCanvas = document.getElementById('edit-canvas');
  editCanvas.innerHTML = '';
  editCanvas.style.width = `${editingBlock.width * CONFIG.editCellSize}px`;
  editCanvas.style.height = `${editingBlock.height * CONFIG.editCellSize}px`;
  editCanvas.style.display = 'grid';
  editCanvas.style.gridTemplateColumns = `repeat(${editingBlock.width}, ${CONFIG.editCellSize}px)`;
  editCanvas.style.gridTemplateRows = `repeat(${editingBlock.height}, ${CONFIG.editCellSize}px)`;

  editingBlock.cells.forEach((row, y) => {
    row.forEach((cell, x) => {
      const cellDiv = createElement('div', 'edit-cell');
      cellDiv.style.width = `${CONFIG.editCellSize}px`;
      cellDiv.style.height = `${CONFIG.editCellSize}px`;
      cellDiv.dataset.x = x;
      cellDiv.dataset.y = y;
      
      const canvas = createElement('canvas');
      canvas.width = CONFIG.editCellSize;
      canvas.height = CONFIG.editCellSize;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.pointerEvents = 'none';
      
      const ctx = canvas.getContext('2d');
      drawCell(ctx, 0, 0, CONFIG.editCellSize, CONFIG.editCellSize, cell.shape, cell.color);
      
      cellDiv.appendChild(canvas);
      cellDiv.addEventListener('click', () => editBlockCell(x, y));
      editCanvas.appendChild(cellDiv);
    });
  });
}

function editBlockCell(x, y) {
  const cellType = getSelectedTileType('editor');
  const color = document.getElementById('cell-color').value;

  if (cellType === 'eraser') {
    editingBlock.cells[y][x] = { shape: 'pixel', color: blockBackground }; // âœ… transparent
  } else {
    editingBlock.cells[y][x] = { shape: cellType, color: color };
  }

  renderEditCanvas();
}

function resizeBlock() {
  if (!editingBlock) return;
  
  const newWidth = Math.max(CONFIG.minBlockSize, Math.min(CONFIG.maxBlockSize, parseInt(document.getElementById('edit-block-width').value)));
  const newHeight = Math.max(CONFIG.minBlockSize, Math.min(CONFIG.maxBlockSize, parseInt(document.getElementById('edit-block-height').value)));
  
  const newCells = Array.from({length: newHeight}, (_, row) =>
    Array.from({length: newWidth}, (_, col) => {
      if (row < editingBlock.height && 
          col < editingBlock.width && 
          editingBlock.cells[row] && 
          editingBlock.cells[row][col]) {
        return editingBlock.cells[row][col];
      }
      return { shape: 'pixel', color: blockBackground };
    })
  );
  
  editingBlock.width = newWidth;
  editingBlock.height = newHeight;
  editingBlock.cells = newCells;
  renderEditCanvas();
}

function clearEditCanvas() {
  editingBlock.cells = Array.from({length: editingBlock.height}, () => 
    Array.from({length: editingBlock.width}, () => ({ shape: 'pixel', color: blockBackground }))
  );
  renderEditCanvas();
}

function saveBlock() {
  const newId = document.getElementById('block-id').value.trim();
  if (!newId) {
    alert('Please enter a block ID');
    return;
  }
  
  editingBlock.id = newId;
  
  if (selectedLibraryBlock !== null) {
    libraryBlocks[selectedLibraryBlock] = editingBlock;
  } else {
    libraryBlocks.push(editingBlock);
  }
  
  renderLibrary();
  closeBlockEditor();
}

function deleteBlock() {
  if (selectedLibraryBlock === null) {
    alert('Please select a block to delete first');
    return;
  }
  
  libraryBlocks.splice(selectedLibraryBlock, 1);
  selectedLibraryBlock = null;
  renderLibrary();
}

// === TILE COUNTER FUNCTIONS ===
function updateTileCount() {
  const display = document.getElementById('count-display');
  const counts = countTiles(boardState);
  display.innerHTML = '';
  
  if (counts.length === 0) {
    display.innerHTML = '<div>No tiles to count</div>';
    return;
  }
  
  counts.forEach(({ shape, color, count }) => {
    const item = createElement('div', 'count-item');
    
    const colorIdx = COLOR_PALETTE.indexOf(color);
    const colorName = colorIdx !== -1 
      ? COLOR_NAMES[colorIdx] 
      : null;

    const colorDiv = createElement('div', 'tile-type-option');
    colorDiv.dataset.tileType = shape;
    
    const canvas = createElement('canvas');
    canvas.width = 30;
    canvas.height = 30;
    const ctx = canvas.getContext('2d');
    
    drawCell(ctx, 5, 5, 20, 20, shape, color);
    
    colorDiv.appendChild(canvas);
    
    const text = createElement('span');
    text.textContent = `${count} (${colorName || color})`;
    
    item.appendChild(colorDiv);
    item.appendChild(text);
    display.appendChild(item);
  });
}

function renderBoard() {
  const canvas = document.getElementById('board');
  canvas.width = boardWidth * CONFIG.cellSize;
  canvas.height = boardHeight * CONFIG.cellSize;
  const ctx = canvas.getContext('2d');

  // Fill background
  ctx.fillStyle = '#0055bf';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Grid lines
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= boardWidth; x++) {
    ctx.beginPath();
    ctx.moveTo(x * CONFIG.cellSize + 0.5, 0);
    ctx.lineTo(x * CONFIG.cellSize + 0.5, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y <= boardHeight; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * CONFIG.cellSize + 0.5);
    ctx.lineTo(canvas.width, y * CONFIG.cellSize + 0.5);
    ctx.stroke();
  }

  // Draw blocks from state
  boardState.blocks.forEach(block => {
    for (let row = 0; row < block.height; row++) {
      for (let col = 0; col < block.width; col++) {
        const cell = block.cells[row][col];
        if (cell) {
          drawCell(
            ctx,
            (block.x + col) * CONFIG.cellSize,
            (block.y + row) * CONFIG.cellSize,
            CONFIG.cellSize,
            CONFIG.cellSize,
            cell.shape,
            cell.color
          );
        }
      }
    }
  });
}

function removeBlockById(blockId) {
  boardState.blocks = boardState.blocks.filter(b => b.id !== blockId);
  renderBoard();
  updateTileCount();
}

// === TEXT INPUT HANDLER ===
function setupTextInputHandler() {
  document.addEventListener('keydown', (event) => {
    // Skip if typing in an input field or modal is open
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || 
        document.getElementById('editor-modal').style.display === 'flex') {
      return;
    }
    
    if (event.code === 'Backspace') {
      // Don't pop borders
      if (boardState.blocks.length > 4) {
        boardState.blocks.pop();
        renderBoard();
        updateTileCount();
      }
    }
    else if (event.code === 'Enter') {
      // Add horizontal line (avoid borders at x=0 and x=boardWidth-1)
      const lineBlock = {
        id: `line_${Date.now()}`,
        width: boardWidth - 2,
        height: 1,
        cells: [
          Array.from({ length: boardWidth - 2 }, () => ({
            shape: 'pixel',
            color: '#000000fe'
          }))
        ]
      };
      addBlockToBoard(lineBlock);
    }
    else {
      if (event.code === 'Space') {
        event.preventDefault();
      }
      // Only letters and digits
      if (event.key.length === 1 && /^[a-zA-Z0-9 :]$/.test(event.key)) {
        const currentText = event.key.toUpperCase();
        if (currentText.length > 0) {
          const input = currentText[currentText.length - 1];
          libraryBlocks.forEach(block => {
            if (input === block.id) {
              addBlockToBoard(block);
            }
          });
        }
      }
    }
  });
}

// === SAVE/LOAD FUNCTIONS ===
function saveBoard() {
  const boardJson = document.getElementById('board-json');
  boardJson.value = JSON.stringify(boardState, null, 2);
}

function loadBoard() {
  const boardJson = document.getElementById('board-json');
  try {
    const data = JSON.parse(boardJson.value);
    
    document.getElementById('board-width').value = data.width / 16;
    document.getElementById('board-height').value = data.height / 16;
    
    generateBoard();
    
    if (data.blocks) {
      data.blocks.forEach(block => {
        placeBlock(block.x, block.y, { 
          width: block.width, 
          height: block.height, 
          cells: block.cells 
        });
      });
    }
    
    updateTileCount();
  } catch (e) {
    alert('Invalid JSON');
  }
}

function saveLibrary() {
  const libraryJson = document.getElementById('library-json');
  libraryJson.value = JSON.stringify(libraryBlocks, null, 2);
}

function loadLibrary() {
  const libraryJson = document.getElementById('library-json');
  try {
    const data = JSON.parse(libraryJson.value);
    libraryBlocks = data;
    renderLibrary();
    selectedLibraryBlock = null;
  } catch (e) {
    alert('Invalid Library JSON');
  }
}

function centerRowBlocks() {
  // Group blocks by Y row
  const rows = {};
  boardState.blocks.forEach(block => {
    if (!rows[block.y]) rows[block.y] = [];
    rows[block.y].push(block);
  });

  // For each row of blocks
  Object.values(rows).forEach(blocks => {
    // Find total span
    const minX = Math.min(...blocks.map(b => b.x));
    const maxX = Math.max(...blocks.map(b => b.x + b.width));
    const rowWidth = maxX - minX;

    // Calculate new starting X to center
    const offsetX = Math.floor((boardWidth - rowWidth) / 2) - minX;

    // Shift blocks
    blocks.forEach(block => {
      block.x += offsetX;
    });
  });

  renderBoard();
  updateTileCount();
}

// === BOARD EVENT HANDLERS ===
function setupBoardEventHandlers() {
  const board = document.getElementById('board');
  
  board.addEventListener('dragover', e => e.preventDefault());
  board.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!draggedData) return;
    
    const rect = board.getBoundingClientRect();
    const dropX = Math.floor((e.clientX - rect.left - draggedData.offsetX) / CONFIG.cellSize);
    const dropY = Math.floor((e.clientY - rect.top - draggedData.offsetY) / CONFIG.cellSize);
    const blockData = draggedData.blockData;
    
    if (
      dropX < 0 || dropX + blockData.width > boardWidth ||
      dropY < 0 || dropY + blockData.height > boardHeight
    ) {
      draggedData = null;
      return;
    }
    
    if (isOverlapping(dropX, dropY, blockData)) {
      alert('Block overlaps another.');
      draggedData = null;
      return;
    }
    
    placeBlock(dropX, dropY, draggedData.blockData);
    draggedData = null;
    updateTileCount();
  });
}

function setupBoardEvents() {
  const canvas = document.getElementById('board');

  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const gridX = Math.floor((e.clientX - rect.left) / CONFIG.cellSize);
    const gridY = Math.floor((e.clientY - rect.top) / CONFIG.cellSize);

    if (e.button === 2) {
      // Right-click â†’ remove block
      const block = findBlockAt(gridX, gridY);
      if (block) removeBlockById(block.id);
      return;
    }

    if (canvasSelectedType === 'bucket') {
      const color = document.getElementById('canvas-cell-color').value;
      bucketFill(gridX, gridY, color);
      renderBoard();
      return;
    }

    // Check if clicked inside an existing block
    const block = findBlockAt(gridX, gridY);
    if (block) {
      isDragging = true;
      draggedBlock = block;
      dragOffset.x = gridX - block.x;
      dragOffset.y = gridY - block.y;

      // Remember original position
      draggedBlock._originalX = block.x;
      draggedBlock._originalY = block.y;
    } else {
      // Default: place pixel block
      editCanvasCell(gridX, gridY);
      renderBoard();
    }
  });

  canvas.addEventListener('mousemove', e => {
    if (!isDragging || !draggedBlock) return;

    const rect = canvas.getBoundingClientRect();
    const gridX = Math.floor((e.clientX - rect.left) / CONFIG.cellSize);
    const gridY = Math.floor((e.clientY - rect.top) / CONFIG.cellSize);

    // Preview move (don't commit yet)
    renderBoard();
    drawBlockGhost(draggedBlock, gridX - dragOffset.x, gridY - dragOffset.y);
  });

  canvas.addEventListener('mouseup', e => {
    if (!isDragging || !draggedBlock) return;

    const rect = canvas.getBoundingClientRect();
    const gridX = Math.floor((e.clientX - rect.left) / CONFIG.cellSize);
    const gridY = Math.floor((e.clientY - rect.top) / CONFIG.cellSize);

    const newX = gridX - dragOffset.x;
    const newY = gridY - dragOffset.y;

    let valid = true;

    // Check bounds
    if (
      newX < 0 ||
      newY < 0 ||
      newX + draggedBlock.width > boardWidth ||
      newY + draggedBlock.height > boardHeight
    ) {
      valid = false;
    }

    // Check overlap
    if (valid) {
      valid = !boardState.blocks.some(b =>
        b !== draggedBlock &&
        newX < b.x + b.width &&
        newX + draggedBlock.width > b.x &&
        newY < b.y + b.height &&
        newY + draggedBlock.height > b.y
      );
    }

    if (valid) {
      // Commit move
      draggedBlock.x = newX;
      draggedBlock.y = newY;
    } else {
      // Snap back
      draggedBlock.x = draggedBlock._originalX;
      draggedBlock.y = draggedBlock._originalY;
    }

    // Clean up
    delete draggedBlock._originalX;
    delete draggedBlock._originalY;

    isDragging = false;
    draggedBlock = null;

    renderBoard();
    updateTileCount();
  });

  // Prevent context menu
  canvas.addEventListener('contextmenu', e => e.preventDefault());
}

function drawBlockGhost(block, x, y) {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');

  ctx.globalAlpha = 0.5;
  for (let row = 0; row < block.height; row++) {
    for (let col = 0; col < block.width; col++) {
      const cell = block.cells[row][col];
      if (cell) {
        drawCell(
          ctx,
          (x + col) * CONFIG.cellSize,
          (y + row) * CONFIG.cellSize,
          CONFIG.cellSize,
          CONFIG.cellSize,
          cell.shape,
          cell.color
        );
      }
    }
  }
  ctx.globalAlpha = 1.0;
}

// === INITIALIZATION FUNCTIONS ===
function setupEventListeners() {
  document.getElementById('font-selector').addEventListener('change', (e) => {
    if (e.target.value) {
      loadFont(e.target.value);
    }
  });

  document.getElementById('filter-input').addEventListener('input', applyFilter);
  document.getElementById('filter-type').addEventListener('change', () => {
    const filterBy = document.getElementById('filter-type').value;
    const filterInput = document.getElementById('filter-input');
    const placeholders = {
      id: 'Filter by ID...',
      width: 'Filter by width (e.g., 3)...',
      height: 'Filter by height (e.g., 5)...'
    };
    filterInput.placeholder = placeholders[filterBy] || 'Filter...';
    applyFilter();
  });

  document.getElementById('generate-board').addEventListener('click', generateBoard);
  document.getElementById('clear-main-canvas').addEventListener('click', clearBoard);
  document.getElementById('print-board').addEventListener('click', printBoard);
  document.getElementById('center-text').addEventListener('click', centerRowBlocks);

  document.getElementById('new-block').addEventListener('click', openNewBlockEditor);
  document.getElementById('edit-block').addEventListener('click', openExistingBlockEditor);
  document.getElementById('delete-block').addEventListener('click', deleteBlock);
  document.getElementById('resize-block').addEventListener('click', resizeBlock);
  document.getElementById('clear-canvas').addEventListener('click', clearEditCanvas);
  document.getElementById('save-block-edit').addEventListener('click', saveBlock);
  document.getElementById('cancel-edit').addEventListener('click', closeBlockEditor);

  document.getElementById('save-board').addEventListener('click', saveBoard);
  document.getElementById('load-board').addEventListener('click', loadBoard);
  document.getElementById('save-library').addEventListener('click', saveLibrary);
  document.getElementById('load-library').addEventListener('click', loadLibrary);
  
  // Modal click outside to close
  document.getElementById('editor-modal').addEventListener('click', (e) => {
    if (e.target === document.getElementById('editor-modal')) {
      closeBlockEditor();
    }
  });
}

// === MAIN INITIALIZATION ===
async function initializeApp() {
  initTileTypeSelector('editor-tile-selector', 'editor', 'editor', { bucket: false, eraser: true });
  initTileTypeSelector('canvas-tile-selector', 'canvas', 'canvas', { bucket: true, eraser: false });
  
  initColorPalette('editor-palette', 'cell-color');
  initColorPalette('canvas-palette', 'canvas-cell-color');
  
  await loadAvailableFonts();
  setupEventListeners();
  setupBoardEventHandlers();
  setupBoardEvents();
  setupTextInputHandler();
  
  generateBoard();
}

document.addEventListener('DOMContentLoaded', initializeApp);

</script>

</body>
</html>