<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AlphaPix</title>
<style>
  :root {
    --cell-size: 15px;
    --edit-cell-size: 40px;
    --border-light: #ddd;
    --border-medium: #999;
    --border-dark: #333;
    --bg-light: #fafafa;
    --bg-medium: #f5f5f5;
    --bg-dark: #f9f9f9;
    --accent-color: #ff0000;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    display: flex;
    gap: 20px;
    padding: 20px;
    margin: 0;
    background: #fff;
  }

  #sidebar {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 320px;
    background: var(--bg-light);
    padding: 15px;
    border-radius: 8px;
    border: 1px solid var(--border-light);
  }

  #main-area {
    display: flex;
    flex-direction: column;
    gap: 20px;
    flex: 1;
  }

  .section {
    background: var(--bg-light);
    padding: 15px;
    border-radius: 8px;
    border: 1px solid var(--border-light);
  }

  .section h3 {
    margin: 0 0 10px 0;
    color: var(--border-dark);
  }

  /* Color Palette Styles */
  .color-palette {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 4px;
    margin: 10px 0;
  }

  .color-swatch {
    width: 30px;
    height: 30px;
    border: 2px solid var(--border-medium);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .color-swatch:hover {
    transform: scale(1.1);
    border-color: var(--border-dark);
  }

  .color-swatch.selected {
    border: 3px solid var(--accent-color);
    transform: scale(1.1);
  }

  /* Input Styles */
  input, select, textarea, button {
    padding: 8px;
    border: 1px solid var(--border-medium);
    border-radius: 4px;
    font-family: inherit;
  }

  button {
    background: white;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  button:hover {
    background: var(--bg-medium);
  }

  button:active {
    background: var(--border-light);
  }

  /* Library Styles */
  #library {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid var(--border-light);
    padding: 10px;
    background: white;
    border-radius: 4px;
  }

  .library-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px;
    cursor: pointer;
    border: 1px solid transparent;
    border-radius: 4px;
    transition: background-color 0.2s ease;
  }

  .library-item:hover {
    background: var(--bg-medium);
  }

  .block {
    border: 1px solid var(--border-medium);
    cursor: grab;
    image-rendering: pixelated;
    border-radius: 2px;
  }

  .block.selected {
    border: 3px solid var(--accent-color);
  }

  .block.hidden {
    display: none;
  }

  /* Board Styles */
  #board {
    position: relative;
    background: white;
    outline: 2px solid var(--border-dark);
    display: grid;
    box-sizing: border-box;
    cursor: crosshair;
    border-radius: 4px;
    line-height: 0;
    font-size: 0;
  }

  .grid-cell {
    width: var(--cell-size);
    height: var(--cell-size);
    border: 0.5px solid #eee;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .grid-cell canvas {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  .placed-block {
    position: absolute;
    image-rendering: pixelated;
    cursor: move;
    z-index: 10;
    border-radius: 2px;
  }

  /* Editor Styles */
  #block-editor {
    background: var(--bg-medium);
    border: 1px solid var(--border-light);
    border-radius: 8px;
    padding: 15px;
    margin-top: 10px;
  }

  #edit-canvas {
    border: 2px solid var(--border-dark);
    background: white;
    border-radius: 4px;
  }

  .edit-cell {
    border: 1px solid var(--border-medium);
    cursor: crosshair;
  }

  /* Controls Layout */
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 15px;
  }

  .control-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .tile-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin: 15px 0;
  }

  /* Tile Type Selector */
  .tile-type-selector {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 8px;
    margin: 10px 0;
  }

  .tile-type-option {
    width: 40px;
    height: 40px;
    border: 2px solid var(--border-medium);
    border-radius: 6px;
    cursor: pointer;
    background: white;
    transition: all 0.2s ease;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .tile-type-option:hover {
    transform: scale(1.05);
    border-color: var(--border-dark);
  }

  .tile-type-option.selected {
    border: 3px solid var(--accent-color);
    transform: scale(1.05);
    background: #f0f8ff;
  }

  .tile-type-option canvas {
    width: 30px;
    height: 30px;
    border-radius: 2px;
  }

  .tile-type-label {
    font-size: 11px;
    color: var(--border-dark);
    text-align: center;
    margin-top: 4px;
    font-weight: 500;
  }

  /* Tile Count Styles */
  .count-item {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    padding: 6px;
    background: white;
    border: 1px solid var(--border-light);
    border-radius: 4px;
  }

  .count-tile-preview {
    width: 24px;
    height: 24px;
    border: 1px solid var(--border-dark);
    border-radius: 2px;
    flex-shrink: 0;
  }

  .count-text {
    font-weight: 500;
    color: var(--border-dark);
  }

  /* Responsive adjustments */
  @media (max-width: 1200px) {
    body {
      flex-direction: column;
    }
    
    #sidebar {
      width: 100%;
    }
  }
</style>
</head>
<body>

<div id="sidebar">
  <div class="section">
    <h3>Font Selection</h3>
    <select id="font-selector">
      <option value="">Loading fonts...</option>
    </select>
  </div>

  <div class="section">
    <h3>Filter Blocks</h3>
    <div class="control-row">
      <select id="filter-type">
        <option value="id">ID</option>
        <option value="width">Width</option>
        <option value="height">Height</option>
      </select>
      <input type="text" id="filter-input" placeholder="Type to filter blocks...">
    </div>
  </div>

  <div class="section">
    <h3>Library Blocks</h3>
    <div id="library"></div>
  </div>

  <div class="section">
    <h3>Block Editor</h3>
    <div class="control-row">
      <button id="new-block">Create New</button>
      <button id="edit-block">Edit Selected</button>
      <button id="delete-block">Delete</button>
    </div>
    <div id="block-editor" style="display: none;">
      <h4>Edit Block: <span id="editing-block-id"></span></h4>
      <div class="control-group">
        <label>Block ID: <input type="text" id="block-id" placeholder="block_name"></label>
      </div>
      <div class="control-row">
        <label>Width: <input type="number" id="edit-block-width" value="3" min="1" max="20"></label>
        <label>Height: <input type="number" id="edit-block-height" value="5" min="1" max="20"></label>
        <button id="resize-block">Resize</button>
      </div>
      
      <div class="tile-controls">
        <div>
          <label><strong>Tile Type:</strong></label>
          <div class="tile-type-selector" id="editor-tile-selector"></div>
        </div>
        <br>
        <div id="edit-canvas"></div><br>
        <div>
          <label><strong>Color:</strong></label>
          <input type="color" id="cell-color" value="#cccccc">
          <div class="color-palette" id="editor-palette"></div>
        </div>
      </div>
      <div class="control-row" style="margin-top: 15px;">
        <button id="clear-canvas">Clear All</button>
        <button id="save-block-edit">Save Block</button>
        <button id="cancel-edit">Cancel</button>
      </div>
    </div>
  </div>
  
  <div class="section">
    <h3>Save / Load Library</h3>
    <div class="control-row">
      <button id="save-library">Export JSON</button>
      <button id="load-library">Import JSON</button>
    </div>
    <textarea id="library-json" rows="4"></textarea>
  </div>
</div>

<div id="main-area">
  <div class="section">
    <div id="board-container">
      <div id="board"></div>
    </div>
  </div>
  
  <div class="section">
    <h3>Board Controls</h3>
    <div class="control-row">
      <label>Board Size:</label>
      <input type="number" id="board-height" value="2" min="1" max="8"> Ã—
      <input type="number" id="board-width" value="2" min="1" max="8">
      <button id="generate-board">Resize</button>
      <button id="clear-main-canvas">Clear Board</button>
      <button id="add-border">Add Border</button>
    </div>
  </div>

  <div class="section">
    <h3>Canvas Editor Tools</h3>
    <div class="tile-controls">
      <div>
        <label><strong>Tile Type:</strong></label>
        <div class="tile-type-selector" id="canvas-tile-selector"></div>
      </div>
      <br>
      <div>
        <label><strong>Color:</strong></label>
        <input type="color" id="canvas-cell-color" value="#cccccc">
        <div class="color-palette" id="canvas-palette"></div>
      </div>
    </div>
  </div>
  
  <div class="section">
    <h3>Tile Count</h3>
    <div id="count-display"></div>
  </div>
  
  <div class="section">
    <h3>Save / Load Board</h3>
    <div class="control-row">
      <button id="save-board">Save Board</button>
      <button id="load-board">Load Board</button>
    </div>
    <textarea id="board-json" rows="4"></textarea>
  </div>
</div>

<script>
// === GLOBAL VARIABLES ===
const CONFIG = {
  cellSize: 15,
  editCellSize: 40,
  maxBoardSize: 128,
  minBoardSize: 8,
  maxBlockSize: 20,
  minBlockSize: 1
};

const possibleFonts = ['04.json','06.json','07+ShadowDown.json',
  '07.json','08.json','09+2xShadownLeft.json','10+2xShadownLeft.json'];
const borderColor = '#078bc9ff';
const COLOR_PALETTE = [
  '#ff0000', '#CCCCCC', "#808080", "#000000", "#FFFFFF",
  "#078bc9", "#ff698f", "#e1d5ed", "#4b9f4a", "#f2cd37"
];
const COLOR_NAMES = [
  "Red", "Grey", "Dark Grey", "Black", "White",
  "Dark Azure", "Coral", "Lavender", "Bright Green", "Yellow"
];

let boardWidth = 32;
let boardHeight = 32;
let draggedData = null;
let libraryBlocks = [];
let availableFonts = [];
let currentFont = '';
let selectedLibraryBlock = null;
let editingBlock = null;
let boardState = {
  width: 32,
  height: 32,
  blocks: []
};

let editorSelectedType = 'pixel';
let canvasSelectedType = 'pixel';
let editorSelectedElement = null;
let canvasSelectedElement = null;

// === UTILITY FUNCTIONS ===
function drawCell(ctx, x, y, cellWidth, cellHeight, shape, color) {
  ctx.fillStyle = color;
  if (shape === 'pixel') {
    ctx.fillRect(x, y, cellWidth, cellHeight);
    return;
  }

  ctx.beginPath();
  const radius = Math.min(cellWidth, cellHeight) / 1;
  
  switch (shape) {
    case 'tl':
      ctx.moveTo(x + radius, y);
      ctx.arc(x + radius, y + radius, radius, 1.5 * Math.PI, Math.PI, true);
      ctx.lineTo(x, y + cellHeight);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x + cellWidth, y);
      break;
    case 'tr':
      ctx.moveTo(x + cellWidth - radius, y);
      ctx.arc(x + cellWidth - radius, y + radius, radius, 1.5 * Math.PI, 0, false);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x, y + cellHeight);
      ctx.lineTo(x, y);
      break;
    case 'bl':
      ctx.moveTo(x, y + cellHeight - radius);
      ctx.arc(x + radius, y + cellHeight - radius, radius, Math.PI, 0.5 * Math.PI, true);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x + cellWidth, y);
      ctx.lineTo(x, y);
      break;
    case 'br':
      ctx.moveTo(x + cellWidth - radius, y + cellHeight);
      ctx.arc(x + cellWidth - radius, y + cellHeight - radius, radius, 0.5 * Math.PI, 0, true);
      ctx.lineTo(x + cellWidth, y);
      ctx.lineTo(x, y);
      ctx.lineTo(x, y + cellHeight);
      break;
  }
  ctx.closePath();
  ctx.fill();
}

function createElement(tag, className = '', attributes = {}) {
  const element = document.createElement(tag);
  if (className) element.className = className;
  Object.entries(attributes).forEach(([key, value]) => {
    element.setAttribute(key, value);
  });
  return element;
}

function countTiles(boardState) {
  const counts = {};

  // Count block cells only (canvas system removed)
  if (boardState.blocks && Array.isArray(boardState.blocks)) {
    boardState.blocks.forEach(block => {
      if (block.cells && Array.isArray(block.cells)) {
        block.cells.forEach(row => {
          if (Array.isArray(row)) {
            row.forEach(cell => {
              if (cell && cell.color && cell.shape) {
                const tile = ['tl','tr','bl','br'].includes(cell.shape) ? 'tl' : cell.shape;
                const key = `${tile}|${cell.color}`;
                counts[key] = (counts[key] || 0) + 1;
              }
            });
          }
        });
      }
    });
  }

  // Convert to array and sort by count descending
  const sorted = Object.entries(counts)
    .map(([key, count]) => {
      const [shape, color] = key.split('|');
      return { shape, color, count };
    })
    .sort((a, b) => b.count - a.count);
  

  return sorted;
  // return counts;
}

// === TILE TYPE SELECTOR FUNCTIONS ===
function initTileTypeSelector(containerId, selectedTypeVar, selectedElementVar) {
  const container = document.getElementById(containerId);
  const tileTypes = [
    { value: 'pixel', label: '3070b' },
    { value: 'tl', label: '25269' },
    { value: 'tr', label: '25269' },
    { value: 'bl', label: '25269' },
    { value: 'br', label: '25269' }
  ];

  container.innerHTML = '';
  
  tileTypes.forEach(tileType => {
    const wrapper = createElement('div');
    wrapper.style.textAlign = 'center';
    
    const option = createElement('div', 'tile-type-option');
    option.dataset.tileType = tileType.value;
    
    const canvas = createElement('canvas');
    canvas.width = 30;
    canvas.height = 30;
    const ctx = canvas.getContext('2d');
    
    drawCell(ctx, 5, 5, 20, 20, tileType.value, '#666666');
    
    option.appendChild(canvas);
    
    const label = createElement('div', 'tile-type-label');
    label.textContent = tileType.label;
    
    wrapper.appendChild(option);
    wrapper.appendChild(label);
    
    option.addEventListener('click', () => {
      if (selectedElementVar === 'editor') {
        if (editorSelectedElement) {
          editorSelectedElement.classList.remove('selected');
        }
        option.classList.add('selected');
        editorSelectedElement = option;
        editorSelectedType = tileType.value;
      } else {
        if (canvasSelectedElement) {
          canvasSelectedElement.classList.remove('selected');
        }
        option.classList.add('selected');
        canvasSelectedElement = option;
        canvasSelectedType = tileType.value;
      }
    });
    
    if (tileType.value === 'pixel') {
      option.classList.add('selected');
      if (selectedElementVar === 'editor') {
        editorSelectedElement = option;
      } else {
        canvasSelectedElement = option;
      }
    }
    
    container.appendChild(wrapper);
  });
}

function getSelectedTileType(selector) {
  return selector === 'editor' ? editorSelectedType : canvasSelectedType;
}

// === COLOR PALETTE FUNCTIONS ===
function initColorPalette(containerId, colorInputId) {
  const container = document.getElementById(containerId);
  const colorInput = document.getElementById(colorInputId);
  let selectedSwatch = null;

  container.innerHTML = '';
  COLOR_PALETTE.forEach(color => {
    const swatch = createElement('div', 'color-swatch');
    swatch.style.backgroundColor = color;
    swatch.dataset.color = color;
    swatch.addEventListener('click', () => {
      if (selectedSwatch) {
        selectedSwatch.classList.remove('selected');
      }
      swatch.classList.add('selected');
      selectedSwatch = swatch;
      colorInput.value = color;
    });
    container.appendChild(swatch);
  });

  colorInput.addEventListener('change', (e) => {
    if (selectedSwatch) {
      selectedSwatch.classList.remove('selected');
      selectedSwatch = null;
    }
  });
}

// === FONT MANAGEMENT FUNCTIONS ===
async function loadAvailableFonts() {
  try {
    availableFonts = [];
    
    for (const font of possibleFonts) {
      try {
        const response = await fetch(`fonts/${font}`);
        if (response.ok) {
          availableFonts.push(font);
        }
      } catch (e) {
        // Font doesn't exist, skip
      }
    }
    
    populateFontSelector();
  } catch (error) {
    console.error('Error loading fonts:', error);
    document.getElementById('font-selector').innerHTML = '<option value="">Error loading fonts</option>';
  }
}

function populateFontSelector() {
  const fontSelector = document.getElementById('font-selector');
  fontSelector.innerHTML = '';
  if (availableFonts.length === 0) {
    fontSelector.innerHTML = '<option value="">No fonts found</option>';
  } else {
    fontSelector.innerHTML = '<option value="">Select a font...</option>';
    availableFonts.forEach(font => {
      const option = createElement('option', '', { value: font });
      option.textContent = font.replace('.json', '');
      fontSelector.appendChild(option);
    });
    
    if (availableFonts.length > 0) {
      fontSelector.value = availableFonts[0];
      loadFont(availableFonts[0]);
    }
  }
}

async function loadFont(fontFile) {
  if (!fontFile) return;
  
  try {
    const response = await fetch(`fonts/${fontFile}`);
    if (!response.ok) throw new Error('Font file not found');
    
    const fontData = await response.json();
    libraryBlocks = [];
    
    fontData.forEach(block => {
      const exists = libraryBlocks.some(b => b.id === block.id);
      if (!exists) {
        libraryBlocks.push(block);
      }
    });
    
    renderLibrary();
    currentFont = fontFile;
  } catch (error) {
    console.error('Error loading font:', error);
    alert(`Error loading font: ${fontFile}`);
  }
}

// === LIBRARY RENDERING FUNCTIONS ===
function renderLibrary() {
  const libraryContainer = document.getElementById('library');
  libraryContainer.innerHTML = '';
  libraryBlocks.forEach((block, index) => {
    const canvas = renderBlockToCanvas(block);
    canvas.draggable = true;
    canvas.dataset.blockIndex = index;
    canvas.title = `Block: ${block.id}`;
    
    canvas.addEventListener('click', (e) => {
      e.preventDefault();
      selectBlock(index, canvas);
    });
    
    canvas.addEventListener('dragstart', (e) => {
      const rect = canvas.getBoundingClientRect();
      draggedData = {
        source: 'library',
        blockData: JSON.parse(JSON.stringify(block)),
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top
      };
    });
    
    libraryContainer.appendChild(canvas);
  });
  
  applyFilter();
}

function renderBlockToCanvas(blockData) {
  const canvas = createElement('canvas', 'block');
  const displayWidth = blockData.width * CONFIG.cellSize;
  const displayHeight = blockData.height * CONFIG.cellSize;
  
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  canvas.width = displayWidth;
  canvas.height = displayHeight;
  
  const ctx = canvas.getContext('2d');
  const cellWidth = displayWidth / blockData.width;
  const cellHeight = displayHeight / blockData.height;
  
  blockData.cells.forEach((row, y) => {
    row.forEach((cell, x) => {
      drawCell(ctx, x * cellWidth, y * cellHeight, cellWidth, cellHeight, cell.shape, cell.color);
    });
  });
  
  return canvas;
}

function selectBlock(index, canvas) {
  document.querySelectorAll('.block').forEach(b => b.classList.remove('selected'));
  canvas.classList.add('selected');
  selectedLibraryBlock = index;
}

function applyFilter() {
  const filterInput = document.getElementById('filter-input');
  const filterType = document.getElementById('filter-type');
  const filterText = filterInput.value.toLowerCase().trim();
  const filterBy = filterType.value;
  const blocks = document.getElementById('library').querySelectorAll('.block');
  
  blocks.forEach((block, index) => {
    const blockData = libraryBlocks[index];
    if (!blockData) return;
    
    let shouldShow = filterText === '';
    
    if (!shouldShow) {
      switch (filterBy) {
        case 'id':
          shouldShow = blockData.id.toLowerCase().includes(filterText);
          break;
        case 'width':
          shouldShow = blockData.width.toString().includes(filterText);
          break;
        case 'height':
          shouldShow = blockData.height.toString().includes(filterText);
          break;
      }
    }
    
    block.classList.toggle('hidden', !shouldShow);
  });
}

// === BOARD MANAGEMENT FUNCTIONS ===
function setBoardSize(width, height) {
  boardWidth = width;
  boardHeight = height;
  boardState.width = width;
  boardState.height = height;
}

function clearBoard() {
  boardState.blocks = [];
}

function generateBoard() {
  const widthInput = document.getElementById('board-width');
  const heightInput = document.getElementById('board-height');
  
  const newWidth = Math.max(CONFIG.minBoardSize, Math.min(CONFIG.maxBoardSize, parseInt(widthInput.value) * 16));
  const newHeight = Math.max(CONFIG.minBoardSize, Math.min(CONFIG.maxBoardSize, parseInt(heightInput.value) * 16));
  
  setBoardSize(newWidth, newHeight);
  clearBoard();
  
  renderGrid();
  updateTileCount();
}

function renderGrid() {
  const boardContainer = document.getElementById('board');
  boardContainer.innerHTML = '';
  boardContainer.style.width = `${boardWidth * CONFIG.cellSize}px`;
  boardContainer.style.height = `${boardHeight * CONFIG.cellSize}px`;
  boardContainer.style.gridTemplateColumns = `repeat(${boardWidth}, ${CONFIG.cellSize}px)`;
  boardContainer.style.gridTemplateRows = `repeat(${boardHeight}, ${CONFIG.cellSize}px)`;
  boardContainer.style.gap = '0';

  for (let row = 0; row < boardHeight; row++) {
    for (let col = 0; col < boardWidth; col++) {
      const cell = createElement('div', 'grid-cell');
      cell.dataset.row = row;
      cell.dataset.col = col;
      
      cell.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        editCanvasCell(col, row);
      });
      
      boardContainer.appendChild(cell);
    }
  }
}

function editCanvasCell(x, y) {
  const cellType = getSelectedTileType('canvas');
  const color = document.getElementById('canvas-cell-color').value;
  
  // Create a 1x1 block for the canvas cell
  const canvasBlockId = `canvas_${x}_${y}_${Date.now()}`;
  const canvasBlock = {
    id: canvasBlockId,
    width: 1,
    height: 1,
    cells: [[{ shape: cellType, color: color }]]
  };
  
  placeBlock(x, y, canvasBlock);
  updateTileCount();
}

function clearCanvas() {
  boardState.blocks = [];
  
  document.querySelectorAll('.placed-block').forEach(block => block.remove());
  
  updateTileCount();
}

function addBorder() {
  //2025-08-18: refactored by a human
  const borderH = {
    id: 'borderH',
    width: boardWidth,
    height: 1,
    cells: [
      Array.from({ length: boardWidth }, () => ({ shape: 'pixel', color: borderColor }))
    ]
  };
  const borderV = {
    id: 'borderV',
    width: 1,
    height: (boardHeight-2),
    cells: Array.from({ length: boardHeight }, () => [{ shape: 'pixel', color: borderColor }])
  };
  
  placeBlock(0, 0, borderH);                //top
  placeBlock(0, (boardHeight-1), borderH);  //bottom
  placeBlock(0, 1, borderV);                //left
  placeBlock((boardWidth-1), 1, borderV);   //right
  updateTileCount();
}

function placeBlock(x, y, blockData) {
  const boardContainer = document.getElementById('board');
  const canvas = renderBlockToCanvas(blockData);
  canvas.className = 'placed-block';
  canvas.style.left = `${x * CONFIG.cellSize}px`;
  canvas.style.top = `${y * CONFIG.cellSize}px`;
  canvas.draggable = true;
  canvas.dataset.gridX = x;
  canvas.dataset.gridY = y;
  
  boardContainer.appendChild(canvas);
  boardState.blocks.push({ 
    x, y, 
    width: blockData.width, 
    height: blockData.height, 
    cells: blockData.cells 
  });

  canvas.addEventListener('dragstart', (e) => {
    const rect = canvas.getBoundingClientRect();
    draggedData = {
      source: 'board',
      blockData: blockData,
      offsetX: e.clientX - rect.left,
      offsetY: e.clientY - rect.top
    };
    
    const idx = boardState.blocks.findIndex(b => b.x === x && b.y === y);
    if (idx >= 0) boardState.blocks.splice(idx, 1);
    boardContainer.removeChild(canvas);
    updateTileCount();
  });
}

function isOverlapping(gridX, gridY, blockData) {
  return boardState.blocks.some(block =>
    gridX < block.x + block.width &&
    gridX + blockData.width > block.x &&
    gridY < block.y + block.height &&
    gridY + blockData.height > block.y
  );
}

function addBlockToCanvas(blockData) {
  let placed = false;
  for (let y = 0; y <= boardHeight - blockData.height && !placed; y++) {
    for (let x = 0; x <= boardWidth - blockData.width && !placed; x++) {
      if (!isOverlapping(x, y, blockData)) {
        placeBlock(x, y, blockData);
        placed = true;
        updateTileCount();
      }
    }
  }
  if (!placed) {
    alert('No space available to place this block');
  }
}

// === BLOCK EDITOR FUNCTIONS ===
function openNewBlockEditor() {
  const width = Math.max(1, Math.min(20, parseInt(document.getElementById('edit-block-width').value) || 3));
  const height = Math.max(1, Math.min(20, parseInt(document.getElementById('edit-block-height').value) || 5));
  
  editingBlock = {
    id: `block_${Date.now()}`,
    width: width,
    height: height,
    cells: Array.from({length: height}, () => 
      Array.from({length: width}, () => ({ shape: 'pixel', color: '#ffffff' }))
    )
  };
  openBlockEditor();
}

function openExistingBlockEditor() {
  if (selectedLibraryBlock === null) {
    alert('Please select a block to edit first');
    return;
  }
  editingBlock = JSON.parse(JSON.stringify(libraryBlocks[selectedLibraryBlock]));
  openBlockEditor();
}

function openBlockEditor() {
  const editorContainer = document.getElementById('block-editor');
  editorContainer.style.display = 'block';
  document.getElementById('editing-block-id').textContent = editingBlock.id;
  document.getElementById('block-id').value = editingBlock.id;
  document.getElementById('edit-block-width').value = editingBlock.width;
  document.getElementById('edit-block-height').value = editingBlock.height;
  renderEditCanvas();
}

function closeBlockEditor() {
  const editorContainer = document.getElementById('block-editor');
  editorContainer.style.display = 'none';
  editingBlock = null;
  selectedLibraryBlock = null;
}

function renderEditCanvas() {
  const editCanvas = document.getElementById('edit-canvas');
  editCanvas.innerHTML = '';
  editCanvas.style.width = `${editingBlock.width * CONFIG.editCellSize}px`;
  editCanvas.style.height = `${editingBlock.height * CONFIG.editCellSize}px`;
  editCanvas.style.display = 'grid';
  editCanvas.style.gridTemplateColumns = `repeat(${editingBlock.width}, ${CONFIG.editCellSize}px)`;
  editCanvas.style.gridTemplateRows = `repeat(${editingBlock.height}, ${CONFIG.editCellSize}px)`;

  editingBlock.cells.forEach((row, y) => {
    row.forEach((cell, x) => {
      const cellDiv = createElement('div', 'edit-cell');
      cellDiv.style.width = `${CONFIG.editCellSize}px`;
      cellDiv.style.height = `${CONFIG.editCellSize}px`;
      cellDiv.dataset.x = x;
      cellDiv.dataset.y = y;
      
      const canvas = createElement('canvas');
      canvas.width = CONFIG.editCellSize;
      canvas.height = CONFIG.editCellSize;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.pointerEvents = 'none';
      
      const ctx = canvas.getContext('2d');
      drawCell(ctx, 0, 0, CONFIG.editCellSize, CONFIG.editCellSize, cell.shape, cell.color);
      
      cellDiv.appendChild(canvas);
      cellDiv.addEventListener('click', () => editBlockCell(x, y));
      editCanvas.appendChild(cellDiv);
    });
  });
}

function editBlockCell(x, y) {
  const cellType = getSelectedTileType('editor');
  const color = document.getElementById('cell-color').value;
  
  editingBlock.cells[y][x] = { shape: cellType, color: color };
  renderEditCanvas();
}

function resizeBlock() {
  if (!editingBlock) return;
  
  const newWidth = Math.max(CONFIG.minBlockSize, Math.min(CONFIG.maxBlockSize, parseInt(document.getElementById('edit-block-width').value)));
  const newHeight = Math.max(CONFIG.minBlockSize, Math.min(CONFIG.maxBlockSize, parseInt(document.getElementById('edit-block-height').value)));
  
  const newCells = Array.from({length: newHeight}, (_, row) =>
    Array.from({length: newWidth}, (_, col) => {
      if (row < editingBlock.height && 
          col < editingBlock.width && 
          editingBlock.cells[row] && 
          editingBlock.cells[row][col]) {
        return editingBlock.cells[row][col];
      }
      return { shape: 'pixel', color: '#cccccc' };
    })
  );
  
  editingBlock.width = newWidth;
  editingBlock.height = newHeight;
  editingBlock.cells = newCells;
  renderEditCanvas();
}

function clearEditCanvas() {
  const color = "#FFFFFF";
  editingBlock.cells = Array.from({length: editingBlock.height}, () => 
    Array.from({length: editingBlock.width}, () => ({ shape: 'pixel', color: color }))
  );
  renderEditCanvas();
}

function saveBlock() {
  const newId = document.getElementById('block-id').value.trim();
  if (!newId) {
    alert('Please enter a block ID');
    return;
  }
  
  editingBlock.id = newId;
  
  if (selectedLibraryBlock !== null) {
    libraryBlocks[selectedLibraryBlock] = editingBlock;
  } else {
    libraryBlocks.push(editingBlock);
  }
  
  renderLibrary();
  closeBlockEditor();
}

function deleteBlock() {
  if (selectedLibraryBlock === null) {
    alert('Please select a block to delete first');
    return;
  }
  
  libraryBlocks.splice(selectedLibraryBlock, 1);
  selectedLibraryBlock = null;
  renderLibrary();
}

// === TILE COUNTER FUNCTIONS ===
function updateTileCount() {
  const display = document.getElementById('count-display');
  const counts = countTiles(boardState);
  display.innerHTML = '';
  
  if (counts.length === 0) {
    display.innerHTML = '<div>No tiles to count</div>';
    return;
  }
  
  // Object.entries(counts).forEach(([key, count]) => {
  counts.forEach(({ shape, color, count }) => {
    // const [shape, color] = key.split('|');
    const item = createElement('div', 'count-item');
    
    const colorIdx = COLOR_PALETTE.indexOf(color);
    const colorName = colorIdx !== -1    // check if it exists
      ? COLOR_NAMES[colorIdx] 
      : null;                                // fallback if not found

    const colorDiv = createElement('div', 'tile-type-option');
    colorDiv.dataset.tileType = shape
    
    const canvas = createElement('canvas');
    canvas.width = 30;
    canvas.height = 30;
    const ctx = canvas.getContext('2d');
    
    drawCell(ctx, 5, 5, 20, 20, shape, color);
    
    colorDiv.appendChild(canvas);
    
    const text = createElement('span');
    text.textContent = `${count} (${colorName})`;
    
    item.appendChild(colorDiv);
    item.appendChild(text);
    display.appendChild(item);
  });
}

// === TEXT INPUT HANDLER ===
function setupTextInputHandler() {
  document.addEventListener('keydown', (event) => {
    if (event.code === 'Backspace') {
      // Remove last item on canvas
      boardState.blocks.pop();
      // Remove last placed block element
      const placedBlocks = document.querySelectorAll('.placed-block');
      if (placedBlocks.length > 0) {
        placedBlocks[placedBlocks.length - 1].remove();
      }
      updateTileCount();
    }
    else {
      if (event.code === 'Space') {
        event.preventDefault(); // Stops the page from scrolling
      }
      const currentText = event.key.toUpperCase();
      if (currentText.length > 0) {
        const input = currentText[currentText.length - 1];
        libraryBlocks.forEach(block => {
          if (input === block.id) {
            addBlockToCanvas(block);
          }
        });
      }
    }
  });
}

// === SAVE/LOAD FUNCTIONS ===
function saveBoard() {
  const boardJson = document.getElementById('board-json');
  boardJson.value = JSON.stringify(boardState, null, 2);
}

function loadBoard() {
  const boardJson = document.getElementById('board-json');
  try {
    const data = JSON.parse(boardJson.value);
    
    document.getElementById('board-width').value = data.width / 16;
    document.getElementById('board-height').value = data.height / 16;
    
    generateBoard();
    
    if (data.blocks) {
      data.blocks.forEach(block => {
        placeBlock(block.x, block.y, { 
          width: block.width, 
          height: block.height, 
          cells: block.cells 
        });
      });
    }
    
    updateTileCount();
  } catch (e) {
    alert('Invalid JSON');
  }
}

function saveLibrary() {
  const libraryJson = document.getElementById('library-json');
  libraryJson.value = JSON.stringify(libraryBlocks, null, 2);
}

function loadLibrary() {
  const libraryJson = document.getElementById('library-json');
  try {
    const data = JSON.parse(libraryJson.value);
    libraryBlocks = data;
    renderLibrary();
    selectedLibraryBlock = null;
  } catch (e) {
    alert('Invalid Library JSON');
  }
}

// === BOARD EVENT HANDLERS ===
function setupBoardEventHandlers() {
  const boardContainer = document.getElementById('board');
  
  // Drop functionality
  boardContainer.addEventListener('dragover', e => e.preventDefault());
  boardContainer.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!draggedData) return;
    
    const rect = boardContainer.getBoundingClientRect();
    const dropX = Math.floor((e.clientX - rect.left - draggedData.offsetX) / CONFIG.cellSize);
    const dropY = Math.floor((e.clientY - rect.top - draggedData.offsetY) / CONFIG.cellSize);
    const blockData = draggedData.blockData;
    
    if (
      dropX < 0 || dropX + blockData.width > boardWidth ||
      dropY < 0 || dropY + blockData.height > boardHeight
    ) {
      draggedData = null;
      return;
    }
    
    if (isOverlapping(dropX, dropY, blockData)) {
      alert('Block overlaps another.');
      draggedData = null;
      return;
    }
    
    placeBlock(dropX, dropY, draggedData.blockData);
    draggedData = null;
    updateTileCount();
  });
}

// === INITIALIZATION FUNCTIONS ===
function setupEventListeners() {
  // Font selector
  document.getElementById('font-selector').addEventListener('change', (e) => {
    if (e.target.value) {
      loadFont(e.target.value);
    }
  });

  // Filter controls
  document.getElementById('filter-input').addEventListener('input', applyFilter);
  document.getElementById('filter-type').addEventListener('change', () => {
    const filterBy = document.getElementById('filter-type').value;
    const filterInput = document.getElementById('filter-input');
    const placeholders = {
      id: 'Filter by ID...',
      width: 'Filter by width (e.g., 3)...',
      height: 'Filter by height (e.g., 5)...'
    };
    filterInput.placeholder = placeholders[filterBy] || 'Filter...';
    applyFilter();
  });

  // Board controls
  document.getElementById('generate-board').addEventListener('click', generateBoard);
  document.getElementById('clear-main-canvas').addEventListener('click', clearCanvas);
  document.getElementById('add-border').addEventListener('click', addBorder);

  // Block editor controls
  document.getElementById('new-block').addEventListener('click', openNewBlockEditor);
  document.getElementById('edit-block').addEventListener('click', openExistingBlockEditor);
  document.getElementById('delete-block').addEventListener('click', deleteBlock);
  document.getElementById('resize-block').addEventListener('click', resizeBlock);
  document.getElementById('clear-canvas').addEventListener('click', clearEditCanvas);
  document.getElementById('save-block-edit').addEventListener('click', saveBlock);
  document.getElementById('cancel-edit').addEventListener('click', closeBlockEditor);

  // Save/Load controls
  document.getElementById('save-board').addEventListener('click', saveBoard);
  document.getElementById('load-board').addEventListener('click', loadBoard);
  document.getElementById('save-library').addEventListener('click', saveLibrary);
  document.getElementById('load-library').addEventListener('click', loadLibrary);
}

// === MAIN INITIALIZATION ===
async function initializeApp() {
  // Initialize tile type selectors
  initTileTypeSelector('editor-tile-selector', 'editor', 'editor');
  initTileTypeSelector('canvas-tile-selector', 'canvas', 'canvas');
  
  // Initialize color palettes
  initColorPalette('editor-palette', 'cell-color');
  initColorPalette('canvas-palette', 'canvas-cell-color');
  
  // Load fonts and setup event listeners
  await loadAvailableFonts();
  setupEventListeners();
  setupBoardEventHandlers();
  setupTextInputHandler();
  
  // Generate initial board
  generateBoard();
}

// Start the application when the DOM is loaded
document.addEventListener('DOMContentLoaded', initializeApp);

</script>

</body>
</html>