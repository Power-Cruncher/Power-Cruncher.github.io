<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AlphaPix</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    display: flex;
    gap: 20px;
    padding: 20px;
    margin: 0;
    background: #fff;
  }

  #sidebar {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 320px;
    background: #fafafa;
    padding: 15px;
    border-radius: 8px;
    border: 1px solid #ddd;
  }

  #main-area {
    display: flex;
    flex-direction: column;
    gap: 20px;
    flex: 1;
  }

  .section {
    background: #fafafa;
    padding: 15px;
    border-radius: 8px;
    border: 1px solid #ddd;
  }

  .section h3 {
    margin: 0 0 10px 0;
    color: #333;
  }

  .color-palette {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 4px;
    margin: 10px 0;
  }

  .color-swatch {
    width: 30px;
    height: 30px;
    border: 2px solid #999;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .color-swatch:hover, .color-swatch.selected {
    transform: scale(1.1);
    border-color: #ff0000;
  }

  input, select, textarea, button {
    padding: 8px;
    border: 1px solid #999;
    border-radius: 4px;
    font-family: inherit;
  }

  button {
    background: white;
    cursor: pointer;
  }

  button:hover {
    background: #f5f5f5;
  }

  #library {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 10px;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #ddd;
    padding: 10px;
    background: white;
    border-radius: 4px;
  }

  .block {
    border: 1px solid #999;
    cursor: grab;
    image-rendering: pixelated;
    border-radius: 2px;
    justify-self: center;
  }

  .block.selected {
    border: 3px solid #ff0000;
  }

  .block.hidden {
    display: none;
  }

  #board {
    position: relative;
    background: white;
    outline: 2px solid #333;
    display: grid;
    box-sizing: border-box;
    cursor: crosshair;
    border-radius: 4px;
    line-height: 0;
    font-size: 0;
  }

  .grid-cell {
    width: 15px;
    height: 15px;
    border: 0.5px solid #eee;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .placed-block {
    position: absolute;
    image-rendering: pixelated;
    cursor: move;
    z-index: 10;
    border-radius: 2px;
  }

  .placed-block.dragging {
    opacity: 0.7;
    z-index: 20;
  }

  .placed-block.selected {
    box-shadow: 0 0 0 3px #ff6b6b;
    z-index: 15;
  }

  .selection-rectangle {
    position: absolute;
    border: 2px dashed #007acc;
    background: rgba(0, 122, 204, 0.1);
    pointer-events: none;
    z-index: 5;
  }

  /* Block Editor Modal Styles */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    display: none;
    align-items: center;
    justify-content: center;
  }

  .modal-content {
    background: white;
    border-radius: 12px;
    padding: 20px;
    max-width: 80vw;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    position: relative;
  }

  .modal-close {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #999;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .modal-close:hover {
    color: #333;
    background: #f0f0f0;
    border-radius: 50%;
  }

  #block-editor {
    background: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 15px;
  }

  #edit-canvas {
    border: 2px solid #333;
    background: white;
    border-radius: 4px;
  }

  .edit-cell {
    border: 1px solid #999;
    cursor: crosshair;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 15px;
  }

  .control-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .tile-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin: 15px 0;
  }

  .tile-type-selector {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    margin: 10px 0;
  }

  .tile-type-option {
    width: 40px;
    height: 40px;
    border: 2px solid #999;
    border-radius: 6px;
    cursor: pointer;
    background: white;
    transition: all 0.2s ease;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .tile-type-option:hover, .tile-type-option.selected {
    transform: scale(1.05);
    border-color: #ff0000;
    background: #f0f8ff;
  }

  .tile-type-option canvas {
    width: 30px;
    height: 30px;
    border-radius: 2px;
  }

  .tile-type-option.bucket-fill {
    font-size: 20px;
    color: #333;
    font-weight: bold;
  }

  .tile-type-option.selection {
    font-size: 16px;
    color: #333;
    font-weight: bold;
  }

  .tile-type-label {
    font-size: 11px;
    color: #333;
    text-align: center;
    margin-top: 4px;
    font-weight: 500;
  }

  .count-item {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    padding: 6px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
  }

  .selection-tools {
    margin-top: 10px;
    padding: 10px;
    background: #e8f4fd;
    border: 1px solid #b3d7f0;
    border-radius: 6px;
    display: none;
  }

  .selection-tools.active {
    display: block;
  }

  @media (max-width: 1200px) {
    body {
      flex-direction: column;
    }
    
    #sidebar {
      width: 100%;
    }
  }
</style>
</head>
<body>

<div id="sidebar">
  <div class="section">
    <h3>Font Selection</h3>
    <select id="font-selector">
      <option value="">Loading fonts...</option>
    </select>
  </div>

  <div class="section">
    <h3>Filter Blocks</h3>
    <div class="control-row">
      <select id="filter-type">
        <option value="id">ID</option>
        <option value="width">Width</option>
        <option value="height">Height</option>
      </select>
      <input type="text" id="filter-input" placeholder="Type to filter blocks...">
    </div>
  </div>

  <div class="section">
    <h3>Library Blocks</h3>
    <div id="library"></div>
  </div>

  <div class="section">
    <h3>Block Editor</h3>
    <div class="control-row">
      <button id="new-block">Create New</button>
      <button id="edit-block">Edit Selected</button>
      <button id="delete-block">Delete</button>
    </div>
  </div>
  
  <div class="section">
    <h3>Save / Load Library</h3>
    <div class="control-row">
      <button id="save-library">Export JSON</button>
      <button id="load-library">Import JSON</button>
    </div>
    <textarea id="library-json" rows="4"></textarea>
  </div>
</div>

<div id="main-area">
  <div class="section">
    <div id="board-container">
      <div id="board"></div>
    </div>
  </div>
  
  <div class="section">
    <h3>Board Controls</h3>
    <div class="control-row">
      <label>Board Size:</label>
      <input type="number" id="board-height" value="2" min="1" max="8"> Ã—
      <input type="number" id="board-width" value="2" min="1" max="8">
      <button id="generate-board">Resize</button>
      <button id="clear-main-canvas">Clear Board</button>
      <button id="add-border">Add Border</button>
      <button id="print-board">Print Board</button>
    </div>
  </div>

  <div class="section">
    <h3>Canvas Editor Tools</h3>
    <div class="tile-controls">
      <div>
        <label><strong>Tool:</strong></label>
        <div class="tile-type-selector" id="canvas-tile-selector"></div>
      </div>
      <br>
      <div>
        <label><strong>Color:</strong></label>
        <input type="color" id="canvas-cell-color" value="#cccccc">
        <div class="color-palette" id="canvas-palette"></div>
      </div>
    </div>
    
    <div class="selection-tools" id="selection-tools">
      <h4>Selection Tools</h4>
      <div class="control-row">
        <button id="copy-selection">Copy</button>
        <button id="move-selection">Move</button>
        <button id="delete-selection">Delete</button>
        <button id="clear-selection">Clear Selection</button>
      </div>
    </div>
  </div>
  
  <div class="section">
    <h3>Tile Count</h3>
    <div id="count-display"></div>
  </div>
  
  <div class="section">
    <h3>Save / Load Board</h3>
    <div class="control-row">
      <button id="save-board">Save Board</button>
      <button id="load-board">Load Board</button>
    </div>
    <textarea id="board-json" rows="4"></textarea>
  </div>
</div>

<!-- Block Editor Modal -->
<div class="modal-overlay" id="editor-modal">
  <div class="modal-content">
    <button class="modal-close" onclick="closeBlockEditor()">Ã—</button>
    <div id="block-editor">
      <h3>Edit Block: <span id="editing-block-id"></span></h3>
      <div class="control-group">
        <label>Block ID: <input type="text" id="block-id" placeholder="block_name"></label>
      </div>
      <div class="control-row">
        <label>Width: <input type="number" id="edit-block-width" value="3" min="1" max="20"></label>
        <label>Height: <input type="number" id="edit-block-height" value="5" min="1" max="20"></label>
        <button id="resize-block">Resize</button>
      </div>
      
      <div class="tile-controls">
        <div>
          <label><strong>Tile Type:</strong></label>
          <div class="tile-type-selector" id="editor-tile-selector"></div>
        </div>
        <br>
        <div id="edit-canvas"></div><br>
        <div>
          <label><strong>Color:</strong></label>
          <input type="color" id="cell-color" value="#cccccc">
          <div class="color-palette" id="editor-palette"></div>
        </div>
      </div>
      <div class="control-row" style="margin-top: 15px;">
        <button id="clear-canvas">Clear All</button>
        <button id="save-block-edit">Save Block</button>
        <button id="cancel-edit">Cancel</button>
      </div>
    </div>
  </div>
</div>

<script>
// === GLOBAL VARIABLES ===
const CONFIG = {
  cellSize: 15,
  editCellSize: 40,
  maxBoardSize: 128,
  minBoardSize: 8,
  maxBlockSize: 20,
  minBlockSize: 1
};

const possibleFonts = ['03.json', '04.json','06.json','07+ShadowDown.json',
  '07.json','08.json','09+2xShadownLeft.json','10+2xShadownLeft.json'];
const borderColor = '#078bc9ff';
const COLOR_PALETTE = [
  '#ff0000', '#CCCCCC', "#808080", "#000000", "#FFFFFF",
  "#078bc9", "#ff698f", "#e1d5ed", "#4b9f4a", "#f2cd37"
];
const COLOR_NAMES = [
  "Red", "Grey", "Dark Grey", "Black", "White",
  "Dark Azure", "Coral", "Lavender", "Bright Green", "Yellow"
];
const blockBackground = '#ffffff00';

let boardWidth = 32;
let boardHeight = 32;
let draggedData = null;
let libraryBlocks = [];
let availableFonts = [];
let currentFont = '';
let selectedLibraryBlock = null;
let editingBlock = null;
let boardState = {
  width: 32,
  height: 32,
  blocks: []
};

let editorSelectedType = 'pixel';
let canvasSelectedType = 'pixel';
let editorSelectedElement = null;
let canvasSelectedElement = null;

// Block drag state
let isDraggingBlock = false;
let draggedBlockElement = null;
let draggedBlockData = null;
let dragOffset = { x: 0, y: 0 };

// Selection state
let isSelectionMode = false;
let isSelecting = false;
let selectionStart = { x: 0, y: 0 };
let selectionEnd = { x: 0, y: 0 };
let selectedBlocks = new Set();
let selectionRectangle = null;

// === UTILITY FUNCTIONS ===
function drawCell(ctx, x, y, cellWidth, cellHeight, shape, color) {
  ctx.fillStyle = color;
  if (shape === 'pixel') {
    ctx.fillRect(x, y, cellWidth, cellHeight);
    return;
  }

  ctx.beginPath();
  const radius = Math.min(cellWidth, cellHeight) / 1;
  
  switch (shape) {
    case 'tl':
      ctx.moveTo(x + radius, y);
      ctx.arc(x + radius, y + radius, radius, 1.5 * Math.PI, Math.PI, true);
      ctx.lineTo(x, y + cellHeight);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x + cellWidth, y);
      break;
    case 'tr':
      ctx.moveTo(x + cellWidth - radius, y);
      ctx.arc(x + cellWidth - radius, y + radius, radius, 1.5 * Math.PI, 0, false);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x, y + cellHeight);
      ctx.lineTo(x, y);
      break;
    case 'bl':
      ctx.moveTo(x, y + cellHeight - radius);
      ctx.arc(x + radius, y + cellHeight - radius, radius, Math.PI, 0.5 * Math.PI, true);
      ctx.lineTo(x + cellWidth, y + cellHeight);
      ctx.lineTo(x + cellWidth, y);
      ctx.lineTo(x, y);
      break;
    case 'br':
      ctx.moveTo(x + cellWidth - radius, y + cellHeight);
      ctx.arc(x + cellWidth - radius, y + cellHeight - radius, radius, 0.5 * Math.PI, 0, true);
      ctx.lineTo(x + cellWidth, y);
      ctx.lineTo(x, y);
      ctx.lineTo(x, y + cellHeight);
      break;
  }
  ctx.closePath();
  ctx.fill();
}

function createElement(tag, className = '', attributes = {}) {
  const element = document.createElement(tag);
  if (className) element.className = className;
  Object.entries(attributes).forEach(([key, value]) => {
    element.setAttribute(key, value);
  });
  return element;
}

function countTiles(boardState) {
  const counts = {};

  if (boardState.blocks && Array.isArray(boardState.blocks)) {
    boardState.blocks.forEach(block => {
      if (block.cells && Array.isArray(block.cells)) {
        block.cells.forEach(row => {
          if (Array.isArray(row)) {
            row.forEach(cell => {
              if (cell && cell.color && cell.shape) {
                const tile = ['tl','tr','bl','br'].includes(cell.shape) ? 'tl' : cell.shape;
                const key = `${tile}|${cell.color}`;
                counts[key] = (counts[key] || 0) + 1;
              }
            });
          }
        });
      }
    });
  }

  const sorted = Object.entries(counts)
    .map(([key, count]) => {
      const [shape, color] = key.split('|');
      return { shape, color, count };
    })
    .sort((a, b) => b.count - a.count);

  return sorted;
}

// === SELECTION FUNCTIONS ===
function toggleSelectionMode() {
  isSelectionMode = !isSelectionMode;
  const selectionTools = document.getElementById('selection-tools');
  
  if (isSelectionMode) {
    selectionTools.classList.add('active');
    document.getElementById('board').style.cursor = 'crosshair';
  } else {
    selectionTools.classList.remove('active');
    clearSelection();
    document.getElementById('board').style.cursor = 'crosshair';
  }
}

function clearSelection() {
  selectedBlocks.clear();
  document.querySelectorAll('.placed-block.selected').forEach(block => {
    block.classList.remove('selected');
  });
  
  if (selectionRectangle) {
    selectionRectangle.remove();
    selectionRectangle = null;
  }
}

function createSelectionRectangle(x1, y1, x2, y2) {
  if (selectionRectangle) {
    selectionRectangle.remove();
  }
  
  const left = Math.min(x1, x2) * CONFIG.cellSize;
  const top = Math.min(y1, y2) * CONFIG.cellSize;
  const width = (Math.abs(x2 - x1) + 1) * CONFIG.cellSize;
  const height = (Math.abs(y2 - y1) + 1) * CONFIG.cellSize;
  
  selectionRectangle = createElement('div', 'selection-rectangle');
  selectionRectangle.style.left = `${left}px`;
  selectionRectangle.style.top = `${top}px`;
  selectionRectangle.style.width = `${width}px`;
  selectionRectangle.style.height = `${height}px`;
  
  document.getElementById('board').appendChild(selectionRectangle);
}

function selectBlocksInArea(x1, y1, x2, y2) {
  const minX = Math.min(x1, x2);
  const maxX = Math.max(x1, x2);
  const minY = Math.min(y1, y2);
  const maxY = Math.max(y1, y2);
  
  boardState.blocks.forEach((block, index) => {
    const blockEndX = block.x + block.width - 1;
    const blockEndY = block.y + block.height - 1;
    
    if (block.x <= maxX && blockEndX >= minX && 
        block.y <= maxY && blockEndY >= minY) {
      selectedBlocks.add(index);
      
      const blockElement = document.querySelector(
        `.placed-block[data-grid-x="${block.x}"][data-grid-y="${block.y}"]`
      );
      if (blockElement) {
        blockElement.classList.add('selected');
      }
    }
  });
}

function copySelection() {
  if (selectedBlocks.size === 0) {
    alert('No blocks selected');
    return;
  }
  
  const selectedBlockData = Array.from(selectedBlocks).map(index => 
    JSON.parse(JSON.stringify(boardState.blocks[index]))
  );
  
  // Store in a simple way for now
  window.copiedBlocks = selectedBlockData;
  console.log('Copied blocks:', selectedBlockData);
}

function deleteSelection() {
  if (selectedBlocks.size === 0) {
    alert('No blocks selected');
    return;
  }
  
  // Sort indices in reverse order to avoid index shifting
  const sortedIndices = Array.from(selectedBlocks).sort((a, b) => b - a);
  
  sortedIndices.forEach(index => {
    const block = boardState.blocks[index];
    const blockElement = document.querySelector(
      `.placed-block[data-grid-x="${block.x}"][data-grid-y="${block.y}"]`
    );
    if (blockElement) {
      blockElement.remove();
    }
    boardState.blocks.splice(index, 1);
  });
  
  clearSelection();
  updateTileCount();
}

// === TILE TYPE SELECTOR FUNCTIONS ===
function initTileTypeSelector(containerId, selectedTypeVar, selectedElementVar) {
  const container = document.getElementById(containerId);
  const tileTypes = [
    { value: 'pixel', label: '3070b' },
    { value: 'tl', label: '25269' },
    { value: 'tr', label: '25269' },
    { value: 'bl', label: '25269' },
    { value: 'br', label: '25269' },
    { value: 'bucket', label: 'Fill' }
  ];
  
  // Add selection tool for canvas only
  if (containerId === 'canvas-tile-selector') {
    tileTypes.push({ value: 'selection', label: 'Select' });
  }

  container.innerHTML = '';
  
  tileTypes.forEach(tileType => {
    const wrapper = createElement('div');
    wrapper.style.textAlign = 'center';
    
    const option = createElement('div', 'tile-type-option');
    option.dataset.tileType = tileType.value;
    
    if (tileType.value === 'bucket') {
      option.classList.add('bucket-fill');
      option.textContent = 'ðŸª£';
    } else if (tileType.value === 'selection') {
      option.classList.add('selection');
      option.textContent = 'ðŸ”²';
    } else {
      const canvas = createElement('canvas');
      canvas.width = 30;
      canvas.height = 30;
      const ctx = canvas.getContext('2d');
      
      drawCell(ctx, 5, 5, 20, 20, tileType.value, '#666666');
      option.appendChild(canvas);
    }
    
    const label = createElement('div', 'tile-type-label');
    label.textContent = tileType.label;
    
    wrapper.appendChild(option);
    wrapper.appendChild(label);
    
    option.addEventListener('click', () => {
      if (selectedElementVar === 'editor') {
        if (editorSelectedElement) {
          editorSelectedElement.classList.remove('selected');
        }
        option.classList.add('selected');
        editorSelectedElement = option;
        editorSelectedType = tileType.value;
      } else {
        if (canvasSelectedElement) {
          canvasSelectedElement.classList.remove('selected');
        }
        option.classList.add('selected');
        canvasSelectedElement = option;
        canvasSelectedType = tileType.value;
        
        // Handle selection mode toggle
        if (tileType.value === 'selection') {
          if (!isSelectionMode) toggleSelectionMode();
        } else {
          if (isSelectionMode) toggleSelectionMode();
        }
      }
    });
    
    if (tileType.value === 'pixel') {
      option.classList.add('selected');
      if (selectedElementVar === 'editor') {
        editorSelectedElement = option;
      } else {
        canvasSelectedElement = option;
      }
    }
    
    container.appendChild(wrapper);
  });
}

function getSelectedTileType(selector) {
  return selector === 'editor' ? editorSelectedType : canvasSelectedType;
}

// === COLOR PALETTE FUNCTIONS ===
function initColorPalette(containerId, colorInputId) {
  const container = document.getElementById(containerId);
  const colorInput = document.getElementById(colorInputId);
  let selectedSwatch = null;

  container.innerHTML = '';
  COLOR_PALETTE.forEach(color => {
    const swatch = createElement('div', 'color-swatch');
    swatch.style.backgroundColor = color;
    swatch.dataset.color = color;
    swatch.addEventListener('click', () => {
      if (selectedSwatch) {
        selectedSwatch.classList.remove('selected');
      }
      swatch.classList.add('selected');
      selectedSwatch = swatch;
      colorInput.value = color;
    });
    container.appendChild(swatch);
  });

  colorInput.addEventListener('change', (e) => {
    if (selectedSwatch) {
      selectedSwatch.classList.remove('selected');
      selectedSwatch = null;
    }
  });
}

// === FONT MANAGEMENT FUNCTIONS ===
async function loadAvailableFonts() {
  try {
    availableFonts = [];
    
    for (const font of possibleFonts) {
      try {
        const response = await fetch(`fonts/${font}`);
        if (response.ok) {
          availableFonts.push(font);
        }
      } catch (e) {
        // Font doesn't exist, skip
      }
    }
    
    populateFontSelector();
  } catch (error) {
    console.error('Error loading fonts:', error);
    document.getElementById('font-selector').innerHTML = '<option value="">Error loading fonts</option>';
  }
}

function populateFontSelector() {
  const fontSelector = document.getElementById('font-selector');
  fontSelector.innerHTML = '';
  if (availableFonts.length === 0) {
    fontSelector.innerHTML = '<option value="">No fonts found</option>';
  } else {
    fontSelector.innerHTML = '<option value="">Select a font...</option>';
    availableFonts.forEach(font => {
      const option = createElement('option', '', { value: font });
      option.textContent = font.replace('.json', '');
      fontSelector.appendChild(option);
    });
    
    if (availableFonts.length > 0) {
      fontSelector.value = availableFonts[0];
      loadFont(availableFonts[0]);
    }
  }
}

async function loadFont(fontFile) {
  if (!fontFile) return;
  
  try {
    const response = await fetch(`fonts/${fontFile}`);
    if (!response.ok) throw new Error('Font file not found');
    
    const fontData = await response.json();
    libraryBlocks = [];
    
    fontData.forEach(block => {
      const exists = libraryBlocks.some(b => b.id === block.id);
      if (!exists) {
        libraryBlocks.push(block);
      }
    });
    
    renderLibrary();
    currentFont = fontFile;
  } catch (error) {
    console.error('Error loading font:', error);
    alert(`Error loading font: ${fontFile}`);
  }
}

// === LIBRARY RENDERING FUNCTIONS ===
function renderLibrary() {
  const libraryContainer = document.getElementById('library');
  libraryContainer.innerHTML = '';
  libraryBlocks.forEach((block, index) => {
    const canvas = renderBlockToCanvas(block);
    canvas.draggable = true;
    canvas.dataset.blockIndex = index;
    canvas.title = `Block: ${block.id}`;
    
    canvas.addEventListener('click', (e) => {
      e.preventDefault();
      selectBlock(index, canvas);
    });
    
    canvas.addEventListener('dragstart', (e) => {
      const rect = canvas.getBoundingClientRect();
      draggedData = {
        source: 'library',
        blockData: JSON.parse(JSON.stringify(block)),
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top
      };
    });
    
    libraryContainer.appendChild(canvas);
  });
  
  applyFilter();
}

function renderBlockToCanvas(blockData) {
  const canvas = createElement('canvas', 'block');
  const displayWidth = blockData.width * CONFIG.cellSize;
  const displayHeight = blockData.height * CONFIG.cellSize;
  
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  canvas.width = displayWidth;
  canvas.height = displayHeight;
  
  const ctx = canvas.getContext('2d');
  const cellWidth = displayWidth / blockData.width;
  const cellHeight = displayHeight / blockData.height;
  
  blockData.cells.forEach((row, y) => {
    row.forEach((cell, x) => {
      drawCell(ctx, x * cellWidth, y * cellHeight, cellWidth, cellHeight, cell.shape, cell.color);
    });
  });
  
  return canvas;
}

function selectBlock(index, canvas) {
  document.querySelectorAll('.block').forEach(b => b.classList.remove('selected'));
  canvas.classList.add('selected');
  selectedLibraryBlock = index;
}

function applyFilter() {
  const filterInput = document.getElementById('filter-input');
  const filterType = document.getElementById('filter-type');
  const filterText = filterInput.value.toLowerCase().trim();
  const filterBy = filterType.value;
  const blocks = document.getElementById('library').querySelectorAll('.block');
  
  blocks.forEach((block, index) => {
    const blockData = libraryBlocks[index];
    if (!blockData) return;
    
    let shouldShow = filterText === '';
    
    if (!shouldShow) {
      switch (filterBy) {
        case 'id':
          shouldShow = blockData.id.toLowerCase().includes(filterText);
          break;
        case 'width':
          shouldShow = blockData.width.toString().includes(filterText);
          break;
        case 'height':
          shouldShow = blockData.height.toString().includes(filterText);
          break;
      }
    }
    
    block.classList.toggle('hidden', !shouldShow);
  });
}

// === BOARD MANAGEMENT FUNCTIONS ===
function setBoardSize(width, height) {
  boardWidth = width;
  boardHeight = height;
  boardState.width = width;
  boardState.height = height;
}

function clearBoard() {
  boardState.blocks = [];
  clearSelection();
}

function generateBoard() {
  const widthInput = document.getElementById('board-width');
  const heightInput = document.getElementById('board-height');
  
  const newWidth = Math.max(CONFIG.minBoardSize, Math.min(CONFIG.maxBoardSize, parseInt(widthInput.value) * 16));
  const newHeight = Math.max(CONFIG.minBoardSize, Math.min(CONFIG.maxBoardSize, parseInt(heightInput.value) * 16));
  
  setBoardSize(newWidth, newHeight);
  clearBoard();
  
  renderGrid();
  updateTileCount();
}

function renderGrid() {
  const boardContainer = document.getElementById('board');
  boardContainer.innerHTML = '';
  boardContainer.style.width = `${boardWidth * CONFIG.cellSize}px`;
  boardContainer.style.height = `${boardHeight * CONFIG.cellSize}px`;
  boardContainer.style.gridTemplateColumns = `repeat(${boardWidth}, ${CONFIG.cellSize}px)`;
  boardContainer.style.gridTemplateRows = `repeat(${boardHeight}, ${CONFIG.cellSize}px)`;
  boardContainer.style.gap = '0';

  for (let row = 0; row < boardHeight; row++) {
    for (let col = 0; col < boardWidth; col++) {
      const cell = createElement('div', 'grid-cell');
      cell.dataset.row = row;
      cell.dataset.col = col;
      
      cell.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!isSelectionMode) {
          editCanvasCell(col, row);
        }
      });
      
      boardContainer.appendChild(cell);
    }
  }
  
  // Always setup selection handlers for the board container
  setupSelectionHandlers(boardContainer);
}

function handleSelectionClick(e, col, row) {
  if (!isSelecting) {
    isSelecting = true;
    selectionStart = { x: col, y: row };
    selectionEnd = { x: col, y: row };
    
    document.addEventListener('mousemove', handleSelectionDrag);
    document.addEventListener('mouseup', handleSelectionEnd);
  }
}

function handleSelectionDrag(e) {
  if (!isSelecting) return;
  
  const boardContainer = document.getElementById('board');
  const rect = boardContainer.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / CONFIG.cellSize);
  const y = Math.floor((e.clientY - rect.top) / CONFIG.cellSize);
  
  if (x >= 0 && x < boardWidth && y >= 0 && y < boardHeight) {
    selectionEnd = { x, y };
    createSelectionRectangle(selectionStart.x, selectionStart.y, selectionEnd.x, selectionEnd.y);
  }
}

function handleSelectionEnd(e) {
  if (!isSelecting) return;
  
  isSelecting = false;
  document.removeEventListener('mousemove', handleSelectionDrag);
  document.removeEventListener('mouseup', handleSelectionEnd);
  
  clearSelection();
  selectBlocksInArea(selectionStart.x, selectionStart.y, selectionEnd.x, selectionEnd.y);
}

function setupSelectionHandlers(boardContainer) {
  // Remove any existing selection handlers
  boardContainer.removeEventListener('mousedown', boardContainer._selectionMouseDown);
  
  const selectionMouseDown = (e) => {
    if (!isSelectionMode) return;
    
    // Prevent interference with block dragging
    if (e.target.classList.contains('placed-block')) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    const rect = boardContainer.getBoundingClientRect();
    const startX = Math.floor((e.clientX - rect.left) / CONFIG.cellSize);
    const startY = Math.floor((e.clientY - rect.top) / CONFIG.cellSize);
    
    // Clear previous selection
    clearSelection();
    
    isSelecting = true;
    selectionStart = { x: startX, y: startY };
    selectionEnd = { x: startX, y: startY };
    
    // Create initial selection rectangle
    createSelectionRectangle(startX, startY, startX, startY);
    
    const mouseMoveHandler = (e) => {
      if (!isSelecting) return;
      
      const rect = boardContainer.getBoundingClientRect();
      const currentX = Math.floor((e.clientX - rect.left) / CONFIG.cellSize);
      const currentY = Math.floor((e.clientY - rect.top) / CONFIG.cellSize);
      
      // Clamp to board boundaries
      const clampedX = Math.max(0, Math.min(boardWidth - 1, currentX));
      const clampedY = Math.max(0, Math.min(boardHeight - 1, currentY));
      
      selectionEnd = { x: clampedX, y: clampedY };
      createSelectionRectangle(selectionStart.x, selectionStart.y, selectionEnd.x, selectionEnd.y);
    };
    
    const mouseUpHandler = (e) => {
      if (!isSelecting) return;
      
      isSelecting = false;
      document.removeEventListener('mousemove', mouseMoveHandler);
      document.removeEventListener('mouseup', mouseUpHandler);
      
      // Select blocks in the final rectangle
      selectBlocksInArea(selectionStart.x, selectionStart.y, selectionEnd.x, selectionEnd.y);
      
      // Remove the selection rectangle after a short delay to show selection
      setTimeout(() => {
        if (selectionRectangle) {
          selectionRectangle.remove();
          selectionRectangle = null;
        }
      }, 200);
    };
    
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
  };
  
  // Store the handler reference for later removal
  boardContainer._selectionMouseDown = selectionMouseDown;
  boardContainer.addEventListener('mousedown', selectionMouseDown);
}

function editCanvasCell(x, y) {
  const cellType = getSelectedTileType('canvas');
  const color = document.getElementById('canvas-cell-color').value;
  
  if (cellType === 'bucket') {
    bucketFill(x, y, color);
    return;
  }
  
  const canvasBlockId = `canvas_${x}_${y}_${Date.now()}`;
  const canvasBlock = {
    id: canvasBlockId,
    width: 1,
    height: 1,
    cells: [[{ shape: cellType, color: color }]]
  };
  
  placeBlock(x, y, canvasBlock);
  updateTileCount();
}

function bucketFill(clickX, clickY, newColor) {
  let targetBlock = null;
  let targetBlockIndex = -1;
  let cellX = -1, cellY = -1;
  
  // Find the block that contains the clicked position
  for (let i = 0; i < boardState.blocks.length; i++) {
    const block = boardState.blocks[i];
    if (clickX >= block.x && clickX < block.x + block.width &&
        clickY >= block.y && clickY < block.y + block.height) {
      targetBlock = block;
      targetBlockIndex = i;
      cellX = clickX - block.x;
      cellY = clickY - block.y;
      break;
    }
  }
  
  if (!targetBlock || !targetBlock.cells || 
      !targetBlock.cells[cellY] || !targetBlock.cells[cellY][cellX]) {
    return;
  }
  
  const originalColor = targetBlock.cells[cellY][cellX].color;
  const originalShape = targetBlock.cells[cellY][cellX].shape;
  
  if (originalColor === newColor) {
    return;
  }
  
  // Flood fill algorithm
  function floodFill(x, y, targetColor, targetShape, newColor) {
    if (x < 0 || x >= targetBlock.width || y < 0 || y >= targetBlock.height) {
      return;
    }
    
    const currentCell = targetBlock.cells[y][x];
    if (!currentCell || currentCell.color !== targetColor || currentCell.shape !== targetShape) {
      return;
    }
    
    // Change the color
    currentCell.color = newColor;
    
    // Recursively fill adjacent cells
    floodFill(x + 1, y, targetColor, targetShape, newColor);
    floodFill(x - 1, y, targetColor, targetShape, newColor);
    floodFill(x, y + 1, targetColor, targetShape, newColor);
    floodFill(x, y - 1, targetColor, targetShape, newColor);
  }
  
  floodFill(cellX, cellY, originalColor, originalShape, newColor);
  
  // Update the visual representation
  const placedBlocks = document.querySelectorAll('.placed-block');
  placedBlocks.forEach(blockElement => {
    const blockX = parseInt(blockElement.dataset.gridX);
    const blockY = parseInt(blockElement.dataset.gridY);
    if (blockX === targetBlock.x && blockY === targetBlock.y) {
      const newCanvas = renderBlockToCanvas(targetBlock);
      newCanvas.className = 'placed-block';
      newCanvas.style.left = `${targetBlock.x * CONFIG.cellSize}px`;
      newCanvas.style.top = `${targetBlock.y * CONFIG.cellSize}px`;
      newCanvas.dataset.gridX = targetBlock.x;
      newCanvas.dataset.gridY = targetBlock.y;
      setupBlockEventHandlers(newCanvas, targetBlock);
      
      blockElement.parentNode.replaceChild(newCanvas, blockElement);
    }
  });
  
  updateTileCount();
}

function clearCanvas() {
  boardState.blocks = [];
  document.querySelectorAll('.placed-block').forEach(block => block.remove());
  clearSelection();
  updateTileCount();
}

function addBorder() {
  const borderH = {
    id: 'borderH',
    width: boardWidth,
    height: 1,
    cells: [
      Array.from({ length: boardWidth }, () => ({ shape: 'pixel', color: borderColor }))
    ]
  };
  const borderV = {
    id: 'borderV',
    width: 1,
    height: (boardHeight-2),
    cells: Array.from({ length: boardHeight-2 }, () => [{ shape: 'pixel', color: borderColor }])
  };
  
  placeBlock(0, 0, borderH);
  placeBlock(0, (boardHeight-1), borderH);
  placeBlock(0, 1, borderV);
  placeBlock((boardWidth-1), 1, borderV);
  updateTileCount();
}

// === PRINT FUNCTION ===
function printBoard() {
  const boardContainer = document.getElementById('board');
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas size to match board
  canvas.width = boardWidth * CONFIG.cellSize;
  canvas.height = boardHeight * CONFIG.cellSize;
  
  // Fill with white background
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw all blocks
  boardState.blocks.forEach(block => {
    const blockCanvas = renderBlockToCanvas(block);
    ctx.drawImage(blockCanvas, block.x * CONFIG.cellSize, block.y * CONFIG.cellSize);
  });
  
  // Convert to blob and open in new tab
  canvas.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const newTab = window.open();
    newTab.document.write(`
      <html>
        <head><title>AlphaPix Board</title></head>
        <body style="margin:0;padding:20px;background:#f0f0f0;display:flex;justify-content:center;align-items:center;min-height:100vh;">
          <img src="${url}" style="max-width:100%;max-height:100%;image-rendering:pixelated;border:2px solid #333;">
        </body>
      </html>
    `);
  }, 'image/png');
}

// === BLOCK DRAG AND DROP FUNCTIONS ===
function setupBlockEventHandlers(canvas, blockData) {
  let clickTimeout = null;

  canvas.addEventListener('mousedown', (e) => {
    e.preventDefault();

    if (canvasSelectedType === 'bucket') {
      const gridX = parseInt(canvas.dataset.gridX);
      const gridY = parseInt(canvas.dataset.gridY);

      // Get click offset within the block
      const rect = canvas.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      const offsetY = e.clientY - rect.top;

      const cellX = Math.floor(offsetX / CONFIG.cellSize);
      const cellY = Math.floor(offsetY / CONFIG.cellSize);

      const clickX = gridX + cellX;
      const clickY = gridY + cellY;
      const color = document.getElementById('canvas-cell-color').value;

      bucketFill(clickX, clickY, color);
      return; // Skip drag
    }
    
    if (isSelectionMode) {
      return; // Let selection mode handle it
    }

    if (clickTimeout) {
      // Double click detected
      clearTimeout(clickTimeout);
      clickTimeout = null;
      removeBlockFromBoard(canvas);
      return;
    }
    
    clickTimeout = setTimeout(() => {
      clickTimeout = null;
      startBlockDrag(e, canvas, blockData);
    }, 200);
  });
  
  canvas.addEventListener('dragstart', (e) => {
    e.preventDefault();
  });
}

function startBlockDrag(e, canvas, blockData) {
  isDraggingBlock = true;
  draggedBlockElement = canvas;
  draggedBlockData = blockData;
  
  const rect = canvas.getBoundingClientRect();
  dragOffset.x = e.clientX - rect.left;
  dragOffset.y = e.clientY - rect.top;
  
  canvas.classList.add('dragging');
  
  // Remove from board state temporarily
  const blockIndex = boardState.blocks.findIndex(b => 
    b.x === parseInt(canvas.dataset.gridX) && b.y === parseInt(canvas.dataset.gridY)
  );
  if (blockIndex >= 0) {
    boardState.blocks.splice(blockIndex, 1);
  }
  
  document.addEventListener('mousemove', handleBlockDrag);
  document.addEventListener('mouseup', handleBlockDrop);
}

function handleBlockDrag(e) {
  if (!isDraggingBlock || !draggedBlockElement) return;
  
  const boardContainer = document.getElementById('board');
  const boardRect = boardContainer.getBoundingClientRect();
  
  const x = e.clientX - boardRect.left - dragOffset.x;
  const y = e.clientY - boardRect.top - dragOffset.y;
  
  draggedBlockElement.style.left = `${x}px`;
  draggedBlockElement.style.top = `${y}px`;
}

function handleBlockDrop(e) {
  if (!isDraggingBlock || !draggedBlockElement || !draggedBlockData) return;
  
  const boardContainer = document.getElementById('board');
  const boardRect = boardContainer.getBoundingClientRect();
  
  const gridX = Math.round((e.clientX - boardRect.left - dragOffset.x) / CONFIG.cellSize);
  const gridY = Math.round((e.clientY - boardRect.top - dragOffset.y) / CONFIG.cellSize);
  
  const originalX = parseInt(draggedBlockElement.dataset.gridX);
  const originalY = parseInt(draggedBlockElement.dataset.gridY);
  
  draggedBlockElement.classList.remove('dragging');
  
  // Check if the new position is valid
  if (gridX >= 0 && gridY >= 0 && 
      gridX + draggedBlockData.width <= boardWidth && 
      gridY + draggedBlockData.height <= boardHeight) {
    
    // Check for overlaps
    const wouldOverlap = boardState.blocks.some(block =>
      gridX < block.x + block.width &&
      gridX + draggedBlockData.width > block.x &&
      gridY < block.y + block.height &&
      gridY + draggedBlockData.height > block.y
    );
    
    if (!wouldOverlap) {
      // Valid position - place the block
      draggedBlockElement.style.left = `${gridX * CONFIG.cellSize}px`;
      draggedBlockElement.style.top = `${gridY * CONFIG.cellSize}px`;
      draggedBlockElement.dataset.gridX = gridX;
      draggedBlockElement.dataset.gridY = gridY;
      
      boardState.blocks.push({
        x: gridX,
        y: gridY,
        width: draggedBlockData.width,
        height: draggedBlockData.height,
        cells: draggedBlockData.cells
      });
    } else {
      // Invalid position - return to original
      draggedBlockElement.style.left = `${originalX * CONFIG.cellSize}px`;
      draggedBlockElement.style.top = `${originalY * CONFIG.cellSize}px`;
      boardState.blocks.push({
        x: originalX,
        y: originalY,
        width: draggedBlockData.width,
        height: draggedBlockData.height,
        cells: draggedBlockData.cells
      });
    }
  } else {
    // Out of bounds - return to original position
    draggedBlockElement.style.left = `${originalX * CONFIG.cellSize}px`;
    draggedBlockElement.style.top = `${originalY * CONFIG.cellSize}px`;
    boardState.blocks.push({
      x: originalX,
      y: originalY,
      width: draggedBlockData.width,
      height: draggedBlockData.height,
      cells: draggedBlockData.cells
    });
  }
  
  // Clean up
  document.removeEventListener('mousemove', handleBlockDrag);
  document.removeEventListener('mouseup', handleBlockDrop);
  isDraggingBlock = false;
  draggedBlockElement = null;
  draggedBlockData = null;
  
  updateTileCount();
}

function removeBlockFromBoard(canvas) {
  const gridX = parseInt(canvas.dataset.gridX);
  const gridY = parseInt(canvas.dataset.gridY);
  
  // Remove from board state
  const blockIndex = boardState.blocks.findIndex(b => b.x === gridX && b.y === gridY);
  if (blockIndex >= 0) {
    boardState.blocks.splice(blockIndex, 1);
  }
  
  // Remove from DOM
  canvas.remove();
  
  updateTileCount();
}

function placeBlock(x, y, blockData) {
  const boardContainer = document.getElementById('board');
  const canvas = renderBlockToCanvas(blockData);
  canvas.className = 'placed-block';
  canvas.style.left = `${x * CONFIG.cellSize}px`;
  canvas.style.top = `${y * CONFIG.cellSize}px`;
  canvas.dataset.gridX = x;
  canvas.dataset.gridY = y;
  
  boardContainer.appendChild(canvas);
  boardState.blocks.push({ 
    x, y, 
    width: blockData.width, 
    height: blockData.height, 
    cells: blockData.cells 
  });

  setupBlockEventHandlers(canvas, blockData);
}

function isOverlapping(gridX, gridY, blockData) {
  return boardState.blocks.some(block =>
    gridX < block.x + block.width &&
    gridX + blockData.width > block.x &&
    gridY < block.y + block.height &&
    gridY + blockData.height > block.y
  );
}

function addBlockToCanvas(blockData) {
  let placed = false;
  for (let y = 0; y <= boardHeight - blockData.height && !placed; y++) {
    for (let x = 0; x <= boardWidth - blockData.width && !placed; x++) {
      if (!isOverlapping(x, y, blockData)) {
        placeBlock(x, y, blockData);
        placed = true;
        updateTileCount();
      }
    }
  }
  if (!placed) {
    alert('No space available to place this block');
  }
}

// === BLOCK EDITOR FUNCTIONS ===
function openNewBlockEditor() {
  const width = Math.max(1, Math.min(20, parseInt(document.getElementById('edit-block-width').value) || 3));
  const height = Math.max(1, Math.min(20, parseInt(document.getElementById('edit-block-height').value) || 5));
  
  editingBlock = {
    id: `block_${Date.now()}`,
    width: width,
    height: height,
    cells: Array.from({length: height}, () => 
      Array.from({length: width}, () => ({ shape: 'pixel', color: blockBackground }))
    )
  };
  openBlockEditor();
}

function openExistingBlockEditor() {
  if (selectedLibraryBlock === null) {
    alert('Please select a block to edit first');
    return;
  }
  editingBlock = JSON.parse(JSON.stringify(libraryBlocks[selectedLibraryBlock]));
  openBlockEditor();
}

function openBlockEditor() {
  const modal = document.getElementById('editor-modal');
  modal.style.display = 'flex';
  document.getElementById('editing-block-id').textContent = editingBlock.id;
  document.getElementById('block-id').value = editingBlock.id;
  document.getElementById('edit-block-width').value = editingBlock.width;
  document.getElementById('edit-block-height').value = editingBlock.height;
  renderEditCanvas();
}

function closeBlockEditor() {
  const modal = document.getElementById('editor-modal');
  modal.style.display = 'none';
  editingBlock = null;
  selectedLibraryBlock = null;
}

function renderEditCanvas() {
  const editCanvas = document.getElementById('edit-canvas');
  editCanvas.innerHTML = '';
  editCanvas.style.width = `${editingBlock.width * CONFIG.editCellSize}px`;
  editCanvas.style.height = `${editingBlock.height * CONFIG.editCellSize}px`;
  editCanvas.style.display = 'grid';
  editCanvas.style.gridTemplateColumns = `repeat(${editingBlock.width}, ${CONFIG.editCellSize}px)`;
  editCanvas.style.gridTemplateRows = `repeat(${editingBlock.height}, ${CONFIG.editCellSize}px)`;

  editingBlock.cells.forEach((row, y) => {
    row.forEach((cell, x) => {
      const cellDiv = createElement('div', 'edit-cell');
      cellDiv.style.width = `${CONFIG.editCellSize}px`;
      cellDiv.style.height = `${CONFIG.editCellSize}px`;
      cellDiv.dataset.x = x;
      cellDiv.dataset.y = y;
      
      const canvas = createElement('canvas');
      canvas.width = CONFIG.editCellSize;
      canvas.height = CONFIG.editCellSize;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.pointerEvents = 'none';
      
      const ctx = canvas.getContext('2d');
      drawCell(ctx, 0, 0, CONFIG.editCellSize, CONFIG.editCellSize, cell.shape, cell.color);
      
      cellDiv.appendChild(canvas);
      cellDiv.addEventListener('click', () => editBlockCell(x, y));
      editCanvas.appendChild(cellDiv);
    });
  });
}

function editBlockCell(x, y) {
  const cellType = getSelectedTileType('editor');
  const color = document.getElementById('cell-color').value;
  
  editingBlock.cells[y][x] = { shape: cellType, color: color };
  renderEditCanvas();
}

function resizeBlock() {
  if (!editingBlock) return;
  
  const newWidth = Math.max(CONFIG.minBlockSize, Math.min(CONFIG.maxBlockSize, parseInt(document.getElementById('edit-block-width').value)));
  const newHeight = Math.max(CONFIG.minBlockSize, Math.min(CONFIG.maxBlockSize, parseInt(document.getElementById('edit-block-height').value)));
  
  const newCells = Array.from({length: newHeight}, (_, row) =>
    Array.from({length: newWidth}, (_, col) => {
      if (row < editingBlock.height && 
          col < editingBlock.width && 
          editingBlock.cells[row] && 
          editingBlock.cells[row][col]) {
        return editingBlock.cells[row][col];
      }
      return { shape: 'pixel', color: blockBackground };
    })
  );
  
  editingBlock.width = newWidth;
  editingBlock.height = newHeight;
  editingBlock.cells = newCells;
  renderEditCanvas();
}

function clearEditCanvas() {
  editingBlock.cells = Array.from({length: editingBlock.height}, () => 
    Array.from({length: editingBlock.width}, () => ({ shape: 'pixel', color: blockBackground }))
  );
  renderEditCanvas();
}

function saveBlock() {
  const newId = document.getElementById('block-id').value.trim();
  if (!newId) {
    alert('Please enter a block ID');
    return;
  }
  
  editingBlock.id = newId;
  
  if (selectedLibraryBlock !== null) {
    libraryBlocks[selectedLibraryBlock] = editingBlock;
  } else {
    libraryBlocks.push(editingBlock);
  }
  
  renderLibrary();
  closeBlockEditor();
}

function deleteBlock() {
  if (selectedLibraryBlock === null) {
    alert('Please select a block to delete first');
    return;
  }
  
  libraryBlocks.splice(selectedLibraryBlock, 1);
  selectedLibraryBlock = null;
  renderLibrary();
}

// === TILE COUNTER FUNCTIONS ===
function updateTileCount() {
  const display = document.getElementById('count-display');
  const counts = countTiles(boardState);
  display.innerHTML = '';
  
  if (counts.length === 0) {
    display.innerHTML = '<div>No tiles to count</div>';
    return;
  }
  
  counts.forEach(({ shape, color, count }) => {
    const item = createElement('div', 'count-item');
    
    const colorIdx = COLOR_PALETTE.indexOf(color);
    const colorName = colorIdx !== -1    // check if it exists
      ? COLOR_NAMES[colorIdx] 
      : null;                                // fallback if not found

    const colorDiv = createElement('div', 'tile-type-option');
    colorDiv.dataset.tileType = shape;
    
    const canvas = createElement('canvas');
    canvas.width = 30;
    canvas.height = 30;
    const ctx = canvas.getContext('2d');
    
    drawCell(ctx, 5, 5, 20, 20, shape, color);
    
    colorDiv.appendChild(canvas);
    
    const text = createElement('span');
    text.textContent = `${count} (${colorName || color})`;
    
    item.appendChild(colorDiv);
    item.appendChild(text);
    display.appendChild(item);
  });
}

// === TEXT INPUT HANDLER ===
function setupTextInputHandler() {
  document.addEventListener('keydown', (event) => {
    // Skip if typing in an input field or modal is open
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || 
        document.getElementById('editor-modal').style.display === 'flex') {
      return;
    }
    
    if (event.code === 'Backspace') {
      if (selectedBlocks.size > 0) {
        deleteSelection();
      } else {
        boardState.blocks.pop();
        const placedBlocks = document.querySelectorAll('.placed-block');
        if (placedBlocks.length > 0) {
          placedBlocks[placedBlocks.length - 1].remove();
        }
        updateTileCount();
      }
    }
    else if (event.code === 'Escape') {
      if (isSelectionMode) {
        toggleSelectionMode();
      }
    }
    else {
      if (event.code === 'Space') {
        event.preventDefault();
      }
      // Only letters and digits
      if (event.key.length === 1 && /^[a-zA-Z0-9]$/.test(event.key)) {
        const currentText = event.key.toUpperCase();
        if (currentText.length > 0) {
          const input = currentText[currentText.length - 1];
          libraryBlocks.forEach(block => {
            if (input === block.id) {
              addBlockToCanvas(block);
            }
          });
        }
      }
    }
  });
}

// === SAVE/LOAD FUNCTIONS ===
function saveBoard() {
  const boardJson = document.getElementById('board-json');
  boardJson.value = JSON.stringify(boardState, null, 2);
}

function loadBoard() {
  const boardJson = document.getElementById('board-json');
  try {
    const data = JSON.parse(boardJson.value);
    
    document.getElementById('board-width').value = data.width / 16;
    document.getElementById('board-height').value = data.height / 16;
    
    generateBoard();
    
    if (data.blocks) {
      data.blocks.forEach(block => {
        placeBlock(block.x, block.y, { 
          width: block.width, 
          height: block.height, 
          cells: block.cells 
        });
      });
    }
    
    updateTileCount();
  } catch (e) {
    alert('Invalid JSON');
  }
}

function saveLibrary() {
  const libraryJson = document.getElementById('library-json');
  libraryJson.value = JSON.stringify(libraryBlocks, null, 2);
}

function loadLibrary() {
  const libraryJson = document.getElementById('library-json');
  try {
    const data = JSON.parse(libraryJson.value);
    libraryBlocks = data;
    renderLibrary();
    selectedLibraryBlock = null;
  } catch (e) {
    alert('Invalid Library JSON');
  }
}

// === BOARD EVENT HANDLERS ===
function setupBoardEventHandlers() {
  const boardContainer = document.getElementById('board');
  
  boardContainer.addEventListener('dragover', e => e.preventDefault());
  boardContainer.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!draggedData) return;
    
    const rect = boardContainer.getBoundingClientRect();
    const dropX = Math.floor((e.clientX - rect.left - draggedData.offsetX) / CONFIG.cellSize);
    const dropY = Math.floor((e.clientY - rect.top - draggedData.offsetY) / CONFIG.cellSize);
    const blockData = draggedData.blockData;
    
    if (
      dropX < 0 || dropX + blockData.width > boardWidth ||
      dropY < 0 || dropY + blockData.height > boardHeight
    ) {
      draggedData = null;
      return;
    }
    
    if (isOverlapping(dropX, dropY, blockData)) {
      alert('Block overlaps another.');
      draggedData = null;
      return;
    }
    
    placeBlock(dropX, dropY, draggedData.blockData);
    draggedData = null;
    updateTileCount();
  });
}

// === INITIALIZATION FUNCTIONS ===
function setupEventListeners() {
  document.getElementById('font-selector').addEventListener('change', (e) => {
    if (e.target.value) {
      loadFont(e.target.value);
    }
  });

  document.getElementById('filter-input').addEventListener('input', applyFilter);
  document.getElementById('filter-type').addEventListener('change', () => {
    const filterBy = document.getElementById('filter-type').value;
    const filterInput = document.getElementById('filter-input');
    const placeholders = {
      id: 'Filter by ID...',
      width: 'Filter by width (e.g., 3)...',
      height: 'Filter by height (e.g., 5)...'
    };
    filterInput.placeholder = placeholders[filterBy] || 'Filter...';
    applyFilter();
  });

  document.getElementById('generate-board').addEventListener('click', generateBoard);
  document.getElementById('clear-main-canvas').addEventListener('click', clearCanvas);
  document.getElementById('add-border').addEventListener('click', addBorder);
  document.getElementById('print-board').addEventListener('click', printBoard);

  document.getElementById('new-block').addEventListener('click', openNewBlockEditor);
  document.getElementById('edit-block').addEventListener('click', openExistingBlockEditor);
  document.getElementById('delete-block').addEventListener('click', deleteBlock);
  document.getElementById('resize-block').addEventListener('click', resizeBlock);
  document.getElementById('clear-canvas').addEventListener('click', clearEditCanvas);
  document.getElementById('save-block-edit').addEventListener('click', saveBlock);
  document.getElementById('cancel-edit').addEventListener('click', closeBlockEditor);

  document.getElementById('save-board').addEventListener('click', saveBoard);
  document.getElementById('load-board').addEventListener('click', loadBoard);
  document.getElementById('save-library').addEventListener('click', saveLibrary);
  document.getElementById('load-library').addEventListener('click', loadLibrary);
  
  // Selection tool event listeners
  document.getElementById('copy-selection').addEventListener('click', copySelection);
  document.getElementById('delete-selection').addEventListener('click', deleteSelection);
  document.getElementById('clear-selection').addEventListener('click', clearSelection);
  
  // Modal click outside to close
  document.getElementById('editor-modal').addEventListener('click', (e) => {
    if (e.target === document.getElementById('editor-modal')) {
      closeBlockEditor();
    }
  });
}

// === MAIN INITIALIZATION ===
async function initializeApp() {
  initTileTypeSelector('editor-tile-selector', 'editor', 'editor');
  initTileTypeSelector('canvas-tile-selector', 'canvas', 'canvas');
  
  initColorPalette('editor-palette', 'cell-color');
  initColorPalette('canvas-palette', 'canvas-cell-color');
  
  await loadAvailableFonts();
  setupEventListeners();
  setupBoardEventHandlers();
  setupTextInputHandler();
  
  generateBoard();
}

document.addEventListener('DOMContentLoaded', initializeApp);

</script>

</body>
</html>